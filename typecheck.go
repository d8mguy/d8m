// Most of the typechecker is here, but it's gotten so big that I split it into 2 files.

package main

import (
	"fmt"
	"sort"
	"strings"
)

// TCCxt is a typechecking context; a Termtag (such as ftnlit, extend, etc) with
// optional properties (stored on a plist). The slice type (below) has relevant methods.
type TCCxt struct {
	tag   Termtag
	plist Plist
}
type TCCxts []TCCxt

func (tcx *TCCxts) Push(tg Termtag) {
	tlen := len(*tcx)
	tcap := cap(*tcx)
	if tlen == tcap {
		*tcx = make(TCCxts, tlen, tcap*2)
	}
	*tcx = (*tcx)[0 : tlen+1]
	(*tcx)[tlen].tag = tg
	(*tcx)[tlen].plist = Plist{}
	// I will add guard related stuff later
}

func (tcx *TCCxts) Pop() {
	tlen := len(*tcx)
	*tcx = (*tcx)[0 : tlen-1]
	// I will add guard related stuff later
}

func (tcx *TCCxts) lastTag() Termtag {
	tlen := len(*tcx)
	if tlen == 0 {
		return NoTerm
	}
	return (*tcx)[tlen-1].tag
}

// Return the index of the rightmost (most recent) occ of tg, or -1.
// Start from index from (which counts backwards, zero most recent), and stop when you see the first stoptag.
// Set stoptag to NoTerm to disable it.
func (tcx *TCCxts) Find(tg Termtag, from int, stoptag Termtag) int {
	tlen := len(*tcx)
	for i := from + 1; i <= tlen; i++ {
		inx := tlen - i
		nxtag := (*tcx)[inx].tag
		if nxtag == tg {
			return inx
		}
		if nxtag == stoptag {
			break
		}
	}
	return -1
}

// SetItemAt allows to set a plist entry at a named index in the cxts list.
func (tcx *TCCxts) SetItemAt(inx int, tg string, val interface{}) {
	(*tcx)[inx].plist.Add(tg, val)
}

// SetItem sets a plist entry at the most recently added cxt list element.
// This will panic if called on an empty cxt list.
func (tcx *TCCxts) SetItem(tg string, val interface{}) {
	inx := len(*tcx) - 1
	(*tcx)[inx].plist.Add(tg, val)
}

// FindItem looks for the named plist entry at the most recently added cxt list element, returning nil if not found.
func (tcx *TCCxts) FindItem(tg string) interface{} {
	if len(*tcx) == 0 {
		return nil
	}
	inx := len(*tcx) - 1
	return (*tcx)[inx].plist.Find(tg)
}

func (tcx *TCCxts) AccumTagAt(inx int, tg string, val interface{}) {
	(*tcx)[inx].plist.Accum(tg, val)
}

// A Guardcxt holds the info needed to record and apply a specific guard condition for a symbol or symchain.
type Guardcxt struct {
	level        int  // created at this nesting level
	kind         int  // 0: about nilposs; 1: about list emptiness; >= 2: about an ortype tag; -1: for typecase of typepred
	pos          bool // else neg
	invalid      bool // arises from negating notFlippable items and when an item is invalidated by asgnmt
	notFlippable bool // generated by a && clause
	posDisable   bool // used in conjunction with || clause
	about        Term // will be Symbol or Symchain
}

func (gdi *Guardcxt) flip() Guardcxt {
	if gdi.notFlippable {
		gdi.invalid = true
	} else {
		gdi.pos = !gdi.pos
		if gdi.posDisable {
			gdi.posDisable = false
			gdi.invalid = false
		}
	}
	return *gdi
}

func (gdi *Guardcxt) String() string {
	return fmt.Sprintf("GC{%d,%d,%v,%v,%v,%s}", gdi.level, gdi.kind, gdi.pos, gdi.invalid, gdi.notFlippable, gdi.about.String())
}

type Gditems []Guardcxt

func (gdis Gditems) String() string {
	var bldr strings.Builder
	bldr.WriteString("[")
	for _, gdi := range gdis {
		bldr.WriteString(gdi.String())
		bldr.WriteString(",")
	}
	bldr.WriteString("]")
	return bldr.String()
}

type TCInfo struct {
	cxt            *TCCxts   // in ftn, extend, assert, etc.
	scopes         *Scope    // current leaf node of scope tree
	typeInDefStack []*Symbol // for self-referential types
	typeInDef      *Symbol   // this is top of the typeInDefStack
	ftnInDef       []*Symbol // for recursive ftns, a stack to handle nested recursive defns
	considered     []*Symbol // hackish thing to help tcFuncall with err msgs
	errors         []Term
	innerError     Term // attempt at improved errmsgs, this will always be an error term or nil
	inXprftn       bool
	allowTilde     bool
	queryOk        bool // used in CLI compiler driver: set true for main REPL file, false for loaded files
	// todo (2022/07/22): I'm a bit worried that exitstmt needs to be stacked in nested ifstmts; check into this
	exitstmt               bool // exit=break+continue+return; cleared when exiting stmtlists
	exitHere               bool // used for a diff purpose from exitstmt: to detect exit followed by code
	inLval                 bool // used to disable guarding when attempting to assign to ortype-valued symchain
	guardctr               int
	gditems                Gditems
	typecaseType           *Type  // holds type of current typecase clause
	tentative              int    // indicate when typecheck caller might back out of errors
	tentCxtCount           int    // cxt count when entering tentative mode
	tentErrCount           int    // error count when entering tentative mode
	tentScope              *Scope // first scope when entering tentative mode
	mqseen                 bool   // used in xprftns for pattern compilation
	backupPos0, backupPosN Pos
	scanner                *Scanner // access to line numbers for error formatting
	rwstoreScope           *Scope   // for rewriteStore when TC'g xprftns
}

// One of these gets passed around, so give it a reasonable # of cxt slots
func makeTCInfo(gblscope *Scope) *TCInfo {
	cxts := make(TCCxts, 0, 30)
	ftns := make([]*Symbol, 0, 2)
	types := make([]*Symbol, 0, 2)
	considered := make([]*Symbol, 0, 4)
	errs := make([]Term, 0, 10)
	gdis := make([]Guardcxt, 0, 20)
	return &TCInfo{&cxts, gblscope, types, nil, ftns, considered, errs,
		nil, false, false, false, false, false, false, 0, gdis, nil, 0,
		0, 0, nil, false, Pos(-1), Pos(-1), nil, nil}
}

// Called when we enter a stmt type that can have a nested scope, such as the body of if or loop.
// Scopes are linked lists, so Push and Pop are easy.
func (tci *TCInfo) PushScope(scp *Scope) {
	scp.parent = tci.scopes
	tci.scopes = scp
}

// Called when we exit a stmt type that can have a nested scope, such as the body of if or loop.
// Also handles cleaning up locally imported modules+pkgs.
// Return the scope just deleted from the scopetree for possible use by the caller.
func (tci *TCInfo) PopScope() *Scope {
	svscope := tci.scopes
	tci.scopes = tci.scopes.parent
	for _, pthnm := range svscope.importPkgs {
		pmentry := QIPathMap[pthnm]
		slot := pmentry.pkg
		slot.activeCount--
		if slot.mname != "" && slot.activeCount == 0 {
			delete(QIScope, slot.mname)
		}
	}
	for _, pthnm := range svscope.importMdls {
		pmentry := QIPathMap[pthnm]
		slot := pmentry.mdl
		slot.activeCount--
		if slot.mname != "" {
			delete(QIScope, slot.mname)
		}
	}
	svscope.clearGTS()
	return svscope
}

func (tci *TCInfo) pushTypeInDef(tidsym *Symbol) {
	tci.typeInDefStack = append(tci.typeInDefStack, tidsym)
	tci.typeInDef = tidsym
}

func (tci *TCInfo) popTypeInDef() {
	stackdepth := len(tci.typeInDefStack) - 1
	if stackdepth == 0 {
		tci.typeInDef = nil
	} else {
		tci.typeInDef = tci.typeInDefStack[stackdepth]
	}
	tci.typeInDefStack = tci.typeInDefStack[:stackdepth]
}

// A method to enter tentative mode. The mode nests but save/restore of state info is needed only when entering.
func (tci *TCInfo) makeTentative() {
	tci.tentative++
	if tci.tentative == 1 {
		tci.tentCxtCount = len(*tci.cxt)
		tci.tentScope = tci.scopes
		tci.tentErrCount = len(tci.errors)
	}
}

// Corresponding method to exit tentative mode. It's useful to return the last error if there is one.
// Thus, the retval is either nil or an Error Term.
func (tci *TCInfo) unmakeTentative() Term {
	tci.tentative--
	var retval Term
	if tci.tentative == 0 {
		if len(tci.errors) > tci.tentErrCount {
			retval = tci.errors[len(tci.errors)-1]
			tci.errors = tci.errors[0:tci.tentErrCount]
		}
		for i := len(*tci.cxt); i > tci.tentCxtCount; i-- {
			tci.cxt.Pop()
		}
		for tci.scopes != tci.tentScope {
			tci.PopScope()
		}
	}
	return retval
}

// To be called at the start of Ifstmt, AndandExpr, and so on.
func (tci *TCInfo) EnterGuardingCxt() {
	tci.guardctr += 1
}

// To be called when completing processing of the expr for which EnterGuardingCxt was called.
func (tci *TCInfo) ExitGuardingCxt(tg Termtag) {
	// lenfound means that we've cleared gditems to the level we should. If it doesn't get set,
	// we clear everything. The rather convoluted logic here relates to keeping gditems to end of the
	// enclosing scope after a conditional break, return, continue, or exit.
	lenfound := false
	if tg == Stmts || tci.exitstmt == false || tg == Typecase {
		// delete items at current nesting level if exiting stmts or if without exitstmt
		for i := len(tci.gditems) - 1; i >= 0; i-- {
			item := &tci.gditems[i]
			if item.level < tci.guardctr {
				tci.gditems = tci.gditems[:i+1]
				lenfound = true
				break
			}
		}
		if tg == IfStmt {
			tci.exitstmt = false // this could be after guards were retained following an if-exit
		}
	} else {
		// must be Ifstmts and tci.exitstmt: flip cond-based guard items instead of deleting
		// also, re-enable items disabled due to assignment
		lenfound = true
		for i := len(tci.gditems) - 1; i >= 0; i-- {
			item := &tci.gditems[i]
			if item.level < tci.guardctr {
				break
			}
			// This ensures that item isn't deleted until exiting next scope down
			if tci.exitstmt && item.level > 0 {
				item.level--
			}
			item.invalid = false
			tci.gditems[i] = item.flip()
		}
	}
	if !lenfound {
		tci.gditems = tci.gditems[:0]
	}
	tci.guardctr -= 1
}

// Called typically when asgnmt causes which to change
func (tci *TCInfo) disableGuard(which Term) {
	for i := len(tci.gditems) - 1; i >= 0; i-- {
		item := &tci.gditems[i]
		if item.about.Equal(which) {
			tci.gditems[i].invalid = true
			break
		}
	}
}

func (tci *TCInfo) addGuarditem(isPos bool, inx int, about Term) {
	newgd := Guardcxt{tci.guardctr, inx, isPos, false, false, false, about}
	gdlen := len(tci.gditems)
	if gdlen == cap(tci.gditems) {
		tci.gditems = append(tci.gditems, newgd)
	} else {
		tci.gditems = tci.gditems[0 : gdlen+1]
		tci.gditems[gdlen] = newgd
	}
}

// maybeGuard is called with the TC'd pairs of operands for equality oprs (incl != etc).
// If the operands imply a guard, it sets one.
func (tci *TCInfo) maybeGuard(poseq bool, a0, a1 Term) {
	// a helpful predicate for guard checking in the equality testing cases, recognizes X.count == 0, X.count != 0
	var count0 = func(left, right Term) bool {
		if left.Tag() == Funcall && right.Tag() == Intlit {
			left0 := left.(*TermTL)
			right0 := right.(*TermB)
			if right0.value == "0" && symbolNamed(left0.trm, "count") {
				if len(left0.args) == 1 && left0.args[0].Dtype().family == TFList {
					return true
				}
			}
		}
		return false
	}
	a0t := a0.Dtype()
	a1t := a1.Dtype()
	if a1t == TypeNil || a0t == TypeNil {
		gdtrm := a0
		if a0t == TypeNil {
			gdtrm = a1
		}
		tci.addGuarditem(!poseq, 0, gdtrm)
	} else if poseq && a0t.isNilposs() && a1t.Equal(a0t.mainType()) {
		// X = Y => X is not nilposs
		tci.addGuarditem(true, 0, a0)
		tci.gditems[len(tci.gditems)-1].notFlippable = true
	} else if poseq && a1t.isNilposs() && a0t.Equal(a1t.mainType()) {
		// X = Y => Y is not nilposs
		tci.addGuarditem(true, 0, a1)
		tci.gditems[len(tci.gditems)-1].notFlippable = true
	} else if count0(a0, a1) {
		// don't bother with checking "0 == count(foo)"
		tci.addGuarditem(!poseq, 1, a0.(*TermTL).args[0])
	} else if a1.Tag() == Litform0 && len(a1.(*TermL).args) == 0 {
		// similarly, don't bother with [] == lst
		tci.addGuarditem(!poseq, 1, a0)
	}
}

// For guarding tag(xxx) = :lbl. We know tag is called, nothing else.
// Return the fully TC'd term or an error.
func (tci *TCInfo) maybeTagGuard(isPos bool, a0, a1 Term) Term {
	a1x := a1.Typecheck(TypeLabel, tci)
	if a1x.Tag() == ErrorTag {
		return a1x
	}
	a1xx := Simplify(a1x)
	if a1xx.Tag() != Labellit {
		return tci.Error("tag(x) comparison to non-manifest expr is not implemented", a1)
	}
	tgargs := a0.(*TermTL).args
	if len(tgargs) != 1 {
		return tci.Error("tag requires a single argument", a0)
	}
	a0x := tgargs[0].Typecheck(nil, tci)
	if a0x.Tag() == ErrorTag {
		return a0x
	} else if a0x.Dtype().family != TFOrtype {
		return tci.Error("tag argument must be ortype", a0)
	}
	a0tv := a0x.Dtype().v.(*Ortype)
	if a0tv.isNilposs {
		return tci.Error("tag of nilpossible isn't implemented", a0)
	}
	rhs := a1xx.(*TermB).value
	inx := 0
	for ; inx < len(a0tv.variants); inx++ {
		if a0tv.variants[inx].ident == rhs {
			break
		}
	}
	if inx == len(a0tv.variants) {
		return tci.Error(fmt.Sprintf(":%s not found in ortype", rhs), a0)
	}
	// create a tag guard, label is encoded into Guardcxt.kind by adding 2 to the index
	tci.addGuarditem(isPos, inx+2, a0x)
	return makeTermTT(Typecond, a0x, a0tv.variants[inx].dtype, TypeBool, Pos(-1), Pos(-1))
}

// This checks if the given Term is active as a nilposs in the list of active guarded items.
// If so, it's going to return it with the correct type, either by smashing or wrapped in a Gdref term.
// Note that we search bkwds from the most recent since it's possible to have contradictory guards
// in the gditems list.
func (tci *TCInfo) tryGuardfixNP(trm Term) Term {
	if trm.Dtype().family != TFOrtype {
		return trm // don't bother
	}
	for i := len(tci.gditems) - 1; i >= 0; i-- {
		gi := tci.gditems[i]
		if gi.kind == 0 && gi.about.Equal(trm) {
			if !gi.invalid {
				if gi.pos {
					if trm.Tag() == SymbolTag {
						sym := trm.(*Symbol)
						return makeTermT(Gdref, sym, sym.dtype.mainType(), Pos(-1), Pos(-1))
					} else {
						smashDtype(trm, trm.Dtype().mainType())
						return trm
					}
				} else {
					return nilEntity
				}
			}
		}
	}
	return trm
}

// Like tryGuardfixNP but for symchains; if successful, it smashes the dtype
// todo: I genzd tryGuardfixNP to work with Terms (vs Symbols); need to fold this in.
func (tci *TCInfo) trySymchainfixNP(symchn *TermL) {
	for i := len(tci.gditems) - 1; i >= 0; i-- {
		gi := tci.gditems[i]
		if gi.kind == 0 && gi.about.Equal(symchn) {
			if gi.pos && !gi.invalid {
				symchn.dtype = symchn.dtype.mainType()
			}
			break
		}
	}
}

func (tci *TCInfo) findListGuard(item Term) *Guardcxt {
	for _, gdi := range tci.gditems {
		if gdi.about.Equal(item) && gdi.kind == 1 && gdi.pos && !gdi.invalid {
			return &gdi
		}
	}
	return nil
}

func (tci *TCInfo) findTagGuard(item Term) *Guardcxt {
	for _, gdi := range tci.gditems {
		if gdi.about.Equal(item) && gdi.kind >= 2 {
			return &gdi
		}
	}
	return nil
}

func (tci *TCInfo) findTypredGuard(item Term) *Guardcxt {
	for _, gdi := range tci.gditems {
		if gdi.about.Equal(item) && gdi.kind == -1 {
			return &gdi
		}
	}
	return nil
}

// Check and clean the (TC'd) boolean-valued term, and put it on the appropriate assertions list.
// If trm is &&, check its parts. If !, attempt to demorganize it. Once it's in parts, check that
// each part mentions self.
// Return nil for success, else an error Term.
func (tci *TCInfo) asserted(trm Term) Term {
	var modOrArgWorkfn func(trm Term, sv interface{}) int
	// looking for symbols that are var or funarg; don't go into any symbol bindings
	modOrArgWorkfn = func(trm Term, sv interface{}) int {
		tg := trm.Tag()
		if tg == SymbolTag {
			sym := trm.(*Symbol)
			if sym.binding == nil || sym.plist.Find("var") != nil || sv.(*TCInfo).scopes.LookupLocal(sym.ident) {
				return -1
			}
			return 1 // no binding search
		}
		return 0
	}
	var clzs []Term
	if trm.Tag() == Lognot && trm.(*TermT).arg0.Tag() == OrorExpr {
		orz := trm.(*TermT).arg0.(*TermL).args
		norz := make([]Term, len(orz))
		for i, x := range orz {
			norz[i] = makeTermT(Lognot, x, TypeBool, x.First(), x.Final())
		}
		trm = makeTermL(AndandExpr, norz, TypeBool, trm.First(), trm.Final())
	}
	if trm.Tag() == AndandExpr {
		clzs = trm.(*TermL).args
	} else {
		clzs = []Term{trm}
	}
	// each clause needs to contain a refnc to self if in extend else to either a var or a funarg.
	xtndinx := tci.cxt.Find(ExtendExpr, 0, FunLit)
	var statevar interface{} = tci
	for _, clz := range clzs {
		workfn := modOrArgWorkfn
		if xtndinx >= 0 {
			workfn = identWorkfn
			statevar = "self"
		}

		if !TraversePre(clz, workfn, statevar) {
			return tci.Error("asserted expression is not quantified", clz)
		}
		// consider guarding
		tg := clz.Tag()
		if tg == EqExpr || tg == NeqExpr || tg == EqeqExpr || tg == NeqeqExpr {
			clz0 := clz.(*TermTT)
			tci.maybeGuard(tg == EqExpr || tg == EqeqExpr, clz0.arg0, clz0.arg1)
		}
	}
	// at this point, quantifn is checked and any cleanups have been done, so put the clauses where they belong
	if xtndinx >= 0 {
		basetype := (*tci.cxt)[xtndinx].plist.Find("basetype").(*Type)
		basetype.initAsserts()
		for _, c := range clzs {
			basetype.asserts.Add(c)
		}
	} else {
		tci.scopes.addAssertions(clzs)
	}
	return nil
}

// Called at top of non-leaf TC methods, record backup positions, with a bit of care
func (tci *TCInfo) RecordBackup(trm Term) {
	p0 := trm.First()
	if p0 != Pos(-1) {
		tci.backupPos0 = p0
		tci.backupPosN = trm.Final()
	}
}

// "General" way to create and record an ErrorTag Term.
func (tci *TCInfo) Error(msg string, trm Term) Term {
	p0 := trm.First()
	pN := trm.Final()
	if p0 == Pos(-1) {
		p0 = tci.backupPos0
		pN = tci.backupPosN
	}
	if tci.tentative == 0 { // this is only here so the debugger has a place to stop when *not* tentative
		tci.tentative++
		tci.tentative--
	}
	errtrm := makeErrorTerm(msg, p0, pN)
	if tci.scanner != nil {
		// add info for formatting error messages
		errtrm.plist.Add("linechar", tci.scanner.getLineCharInfo(p0.byteIndex(), tci.scanner.fname))
	}
	tci.errors = append(tci.errors, errtrm)
	return errtrm
}

func (tci *TCInfo) ClearErrors() {
	tci.errors = tci.errors[0:0]
}

// MissingFeature is a specialized variant of TCInfo.Error: missing feature: dtl
func (tci *TCInfo) MissingFeature(dtl string, trm Term) Term {
	return tci.Error("missing feature: "+dtl, trm)
}

// ErrorExpect is a specialized variant of TCInfo.Error: expected A but found B
func (tci *TCInfo) ErrorExpect(good, found *Type, trm Term) Term {
	msg := fmt.Sprintf("expected %s but found %s", good.String(), found.String())
	return tci.Error(msg, trm)
}

// ErrorExpectStmt is a specialized variant of TCInfo.Error: X stmt where value of type T reqd
func (tci *TCInfo) ErrorExpectStmt(stmt string, reqmt *Type, trm Term) Term {
	msg := fmt.Sprintf("%s statement where value of type %s required", stmt, reqmt.String())
	return tci.Error(msg, trm)
}

// ErrorNoType is a specialized variant of TCInfo.Error: X cannot be a type
func (tci *TCInfo) ErrorNotype(typ Term, trm Term) Term {
	msg := fmt.Sprintf("%s cannot be a type", typ.String())
	return tci.Error(msg, trm)
}

// ErrorCxt is a specialized variant of TCInfo.Error: X may only occur in a Y
func (tci *TCInfo) ErrorCxt(found string, wanted string, trm Term) Term {
	msg := fmt.Sprintf("%s may only occur in a %s", found, wanted)
	return tci.Error(msg, trm)
}

// This is just to record a previously created error Term, presumably because it
// was tentative when created.
func (tci *TCInfo) RecordError(errtrm Term) {
	tci.errors = append(tci.errors, errtrm)
}

func generalizedType(ty *Type) bool {
	return ty == Gzterm || ty == Gzsym || ty == Gzstmts
}

// Let's start with typechecking for types. This can only occur with tags Ident
// (type Token), Funcall (type TermTL), ExtendExpr (type TermTT), or several tags a/w type
// TermL (FunTypeLit, OrtypeLit, TupleTypeLit). Therefore, to get full TC for types, we have a
// method per concrete type, called check4Type. TC4TYpe wraps those calls in a cntt check.
// TC4Type should be called when there's no type-entity ambiguity, so that if the type interpretation
// fails, we can declare an error. For ambiguous cases, we usually check first, then call check4Type.
func TC4Type(trm Term, cntt *Type, tci *TCInfo) Term {
	var trm0 Term
	switch trmt := trm.(type) {
	case *Token:
		trm0 = trmt.check4Type(tci)
	case *TermTL:
		if trmt.Tag() == Funcall && trmt.trm.Tag() == Ident {
			trmId := trmt.trm.(*Token).val
			if trmId == "label" || trmId == "type" || trmId == "elttype" {
				trm0 = funcallTypeSpecial(trmt, trmId, tci)
			}
		}
		if trm0 == nil {
			trm0 = trmt.check4Type(tci)
		}
	case *TermL:
		trm0 = trmt.check4Type(tci)
	case *TermTT:
		trm0 = trmt.check4Type(tci)
	default:
		trm0 = tci.Error("cannot be a type", trm)
	}
	if cntt != nil && trm0.Tag() != ErrorTag {
		typ := trm0.(*Type)
		var ok bool
		if cntt.family == TFTypred {
			ok = cntt.v.(*Typred).match(typ)
		} else if cntt.family == TFGTS {
			gts := cntt.v.(*GTS)
			tpred := gts.dtype
			ok = tpred == TPEntity || tpred.v.(*Typred).match(typ)
		} else {
			seen := []*Type{}
			ok = typ.compat(cntt, &seen)
		}
		if !ok {
			return tci.Error(fmt.Sprintf("%s doesn't match constraint %s", trm.String(), cntt.String()), trm)
		}
	}
	return trm0
}

// Handle special cases of "funcall-like" types that are built in and not in symtbls for various reasons.
// Specifically, these are label(...), elttype(...), and type(X) in xprftn cxt.
// The trmId arg extracts these.
func funcallTypeSpecial(fcall *TermTL, trmId string, tci *TCInfo) Term {
	if trmId == "type" || trmId == "elttype" {
		// Now these are available in xprftns and fns returning generics
		inGnc := false
		fnlitInx := tci.cxt.Find(FunLit, 0, NoTerm)
		var retcntt interface{}
		if fnlitInx >= 0 {
			retcntt = (*tci.cxt)[fnlitInx].plist.Find("retcntt")
		}
		if retcntt != nil {
			inGnc = retcntt.(*Type).family == TFTypred
		}
		if !(tci.inXprftn || inGnc) {
			return tci.Error(fmt.Sprintf("%s(x) is only available in xprftns", trmId), fcall.args[0])
		}
		if len(fcall.args) != 1 {
			return tci.Error(fmt.Sprintf("%s() has a single argument", trmId), fcall)
		}
		if trmId == "type" {
			a0 := fcall.args[0].Typecheck(nil, tci)
			if a0.Tag() == ErrorTag {
				return a0
			}
			if tci.inXprftn && tci.mqseen { // "quote" calls to type in eval phase of rwrule
				return makeFuncall(XprScope.entries.Find(trmId), []Term{a0}, Gztype, nil)
			}
			return a0.Dtype()
		} else {
			quoted := tci.inXprftn && tci.mqseen
			var a0 Term
			if tokenNamed(fcall.args[0], "expectedType") {
				a0 = tci.scopes.lookupType("expectedType")
				if a0 == nil {
					a0 = tci.Error("can't find expectedType", fcall)
				}
				quoted = true
			} else {
				a0 = TC4Type(fcall.args[0], nil, tci)
			}
			if a0.Tag() == ErrorTag {
				return a0
			}
			if quoted { // "quote" calls to type in eval phase of rwrule
				return makeFuncall(XprScope.entries.Find(trmId), []Term{a0}, Gztype, nil)
			}
			return a0
		}
	} else if trmId == "label" {
		// check that all args are labels and extract their string values.
		strgs := make([]string, len(fcall.args))
		for i, lbl := range fcall.args {
			if lbl.Tag() != Labellit {
				return tci.Error(fmt.Sprintf("ELT arguments must be manifest labels which %s is not", lbl.String()), lbl)
			}
			strgs[i] = lbl.(*TermB).value
		}
		return makeSmallint(strgs)
	}
	panic("not reached")
}

// check4Type on Token returns either *Symbol (which implements Term) or ErrorTag term.
// Here, we handle lookup in the scope stack provided by tci.
func (t *Token) check4Type(tci *TCInfo) Term {
	if tci.typeInDef != nil && tci.typeInDef.ident == t.val {
		tci.typeInDef.binding.Plist().Add("rectypeMentioned", true)
		return tci.typeInDef.binding
	}
	sym := tci.scopes.lookupType(t.val)
	if sym == nil {
		// types in xprftns need a bit of special casing.
		if tci.inXprftn {
			if t.val == "type" {
				return Gztype
			}
			sym = tci.scopes.LookupN(t.val, 0)
			if sym != nil {
				if sym.dtype == Gztype {
					return sym
				}
				if sym.dtype == nil && sym.binding.Tag() == IfStmt {
					return sym
				}
				if sym.dtype == Gzsym && callingNamed(sym.binding, "mksym") {
					symtyp := sym.binding.(*TermTL).args[1]
					if symtyp.Tag() == Labellit && symtyp.(*TermB).value == "type" {
						return sym
					}
				}
			}
		}
		return tci.Error(fmt.Sprintf("didn't find a type named %s", t.val), t)
	} else if tci.inXprftn && sym.binding != nil && sym.binding.Dtype() == Gztype {
		return sym
	}
	if sym.ident == "expectedType" {
		// this is a fairly horrible hack but I need a way for the caller to detect if expectedType was used
		sym.plist.Add("used", true)
	}
	typ := sym.binding.(*Type)
	return typ
}

// Helper for ELT decls. When these are declared we create a "piggyback" integer type that'll be their final form.
func makeSmallint(strgs []string) *Type {
	smint := TypeInt.Copy().(*Type)
	ge := smint.methodLookup(">=")
	lt := smint.methodLookup("<")
	ssym := makeSymbol("self", smint, nil)
	asrt1 := makeFuncall(ge, []Term{ssym, makeIntTerm2(0)}, TypeBool, nil)
	asrt2 := makeFuncall(lt, []Term{ssym, makeIntTerm2(len(strgs))}, TypeBool, nil)
	smint.initAsserts()
	smint.asserts.Add(asrt1)
	smint.asserts.Add(asrt2)
	smint.plist.Add("ELT", strgs)
	return smint
}

// Another ELT helper, to get the index of a given string in an ELT
func indexELT(typ *Type, strg string) int {
	if typ.family == TFInt {
		eltitem := typ.plist.Find("ELT")
		if eltitem != nil {
			eltstrgs := eltitem.([]string)
			return stringInStrings(strg, eltstrgs)
		}
	}
	return -1
}

// Try to interpret a term as a typegen. This works if it's defined as a typegen as either (1) a token or (2) a QI.token.
func findTypegen(trm Term, tci *TCInfo) *Typegen {
	ttg := trm.Tag()
	var tgs *Symbol
	if ttg == Ident {
		tgs = tci.scopes.lookupTypegen(trm.(*Token).val)
	} else if ttg == Dot {
		ttrm := trm.(*TermTT)
		if ttrm.arg0.Tag() == Ident {
			qis := QIScope[ttrm.arg0.(*Token).val]
			if qis != nil {
				tgs = qis.scope.lookupTypegen(ttrm.arg1.(*Token).val)
			}
		}
	}
	if tgs != nil {
		return tgs.binding.(*Typegen)
	}
	return nil
}

// check4Type on TermTL handles types that the parser presents as funcalls and that are in a symbol table.
// This includes all type generators (incl such BI ones as list, space, Gomap,...). ELT (label) and xprftn type exprs
// should be filtered out prior to calling this check4Type
func (t *TermTL) check4Type(tci *TCInfo) Term {
	if t.kind != Funcall {
		return tci.ErrorNotype(t, t)
	}
	tgen := findTypegen(t.trm, tci)
	tgident := t.trm.String()
	if tgen == nil {
		return tci.Error(fmt.Sprintf("didn't find a typegen named %s", tgident), t)
	}
	if tokenNamed(t.trm, "Gomap") && tci.cxt.Find(GomapAllowed, 0, NoTerm) < 0 {
		return tci.Error("Gomap is not allowed here", t)
	}

	// We have a typegen; match its args vs actuals and bind them into a scope.
	if len(t.args) != len(tgen.funargs) {
		msg := fmt.Sprintf("%s needs %d arguments but %d were given", tgident, len(tgen.funargs), len(t.args))
		return tci.Error(msg, t)
	}
	// tgen's dtype should normally be generic though in obscure cases it might not be.
	// Recall that if not nil, gnc will be a non-empty []*Symbol, with all elts
	// sharing a scope
	actuals := make([]Term, len(tgen.funargs))
	givenscope := tgen.plist.Find("givenscope")
	if givenscope != nil {
		tci.PushScope(givenscope.(*Scope))
		defer tci.PopScope()
	}
	for i, tga := range tgen.funargs {
		actual0 := t.args[i]
		var actual Term
		if tga.dtype == nil {
			// arg is a GTS, run TC4Type
			actual = TC4Type(actual0, tga.binding.(*Type), tci)
		} else {
			// arg is a GES, do std TC on it
			actual = actual0.Typecheck(tga.dtype, tci)
		}
		if actual.Tag() == ErrorTag {
			return actual
		}
		actuals[i] = actual
	}
	var postGiven []*Symbol // this is in case we have GTS bound to GTS
	czi := makeConczInfo(tgen.funargs, actuals)
	if givenscope != nil {
		// here, ensure inferred generics get substd in the body and check for "equivalenced" GTS
		gse := givenscope.(*Scope).entries
		for _, sx := range gse {
			if sx.sym.dtype == nil {
				gts := sx.sym.binding.(*Type).v.(*GTS)
				if gts.binding != nil {
					conctyp := gts.binding
					czi.gnctypes = append(czi.gnctypes, sx.sym.binding.(*Type))
					czi.conctypes = append(czi.conctypes, conctyp)
					if conctyp.family == TFGTS {
						// yes, this is squirrelly, see below for what's going on
						ctsym := tci.scopes.lookupType(conctyp.v.(*GTS).ident)
						postGiven = append(postGiven, ctsym)
					}
				}
			}
		}
	}
	rettype := tgen.Instantiate0(czi)
	if postGiven != nil {
		pgscope := makeScope()
		for _, s := range postGiven {
			pgscope.Add(s, 0)
		}
		rettype.plist.Add("givenscope", pgscope)
	}
	return rettype
}

// check4Type on TermTT handles extend and qi.typ exprs
func (t *TermTT) check4Type(tci *TCInfo) Term {
	if t.kind == Dot && t.arg0.Tag() == Ident && t.arg1.Tag() == Ident {
		mname := t.arg0.(*Token).val
		qis := QIScope[mname]
		var errmsg string
		if qis != nil {
			typident := t.arg1.(*Token).val
			sym := qis.scope.lookupType(typident)
			if sym != nil {
				return sym.binding
			} else {
				errmsg = fmt.Sprintf("%s not found in %s", typident, mname)
			}
		} else {
			errmsg = fmt.Sprintf("%s expected to be qualified identifier", mname)
		}
		return tci.Error(errmsg, t)
	} else if t.kind != ExtendExpr {
		return tci.Error("cannot be a type", t)
	}
	return t.tcExtend(tci)
}

// TCAttrib handles a single Symdecl whose role is to decl an attrib. That means len(symdecl.args) == 2; privacy
// info comes in as an arg.
// Return either a *Bdgpt or an error Term.
func (symdecl *TermL) TCAttrib(pvt bool, tci *TCInfo) (bpt *Symbol, err Term) {
	idtkn := symdecl.args[0].(*Token)
	typ := TC4Type(symdecl.args[1], nil, tci)
	if typ.Tag() == ErrorTag {
		err = typ
		return
	}
	typ0 := typ.(*Type)
	bpt = makeSymbol(idtkn.val, typ0, nil)
	if pvt {
		bpt.plist.Add("private", TrueLiteral)
	}
	return
}

// Given a tuple type, check if any attribs have their own $== method; if so synth and set a $== for this one.
// We don't need to do a full recursive traversal because types are built up in steps due to the def before use rule.
// The synthd method consists of a single && over all of the attributes
func synthEqMethod(typ *Type, tci *TCInfo) {
	if typ.family != TFTuple {
		panic("bad call to synthEqMethod")
	}
	tupt := typ.v.(*Tupletype)
	anyEq := false
	for _, a := range tupt.attribs {
		if a.dtype.methods.Find("==") != nil {
			anyEq = true
			break
		}
	}
	if anyEq {
		eqsym := makeSymbol("==", makeType(TFFtn, []*Type{typ, typ}, TypeBool, true), nil)
		funiscp := makeScope()
		funiscp.parent = tci.scopes
		asym := makeSymbol("a", typ, nil)
		bsym := makeSymbol("b", typ, nil)
		funiscp.Add(asym, 0)
		funiscp.Add(bsym, 0)
		funargs := []*Symbol{asym, bsym}
		bodyscp := makeScope()
		(bodyscp) = funiscp
		aaparts := make([]Term, len(tupt.attribs))
		for i, a := range tupt.attribs {
			atyp := a.dtype
			arg1 := makeTermL(Symchain, []Term{asym, a}, atyp, Pos(-1), Pos(-1))
			arg2 := makeTermL(Symchain, []Term{bsym, a}, atyp, Pos(-1), Pos(-1))
			var eqtest Term
			eqmthd := atyp.methods.Find("==")
			if eqmthd != nil {
				eqtest = makeFuncall(eqmthd, []Term{arg1, arg2}, TypeBool, nil)
			} else {
				eqtest = makeTermTT(EqExpr, arg1, arg2, TypeBool, Pos(-1), Pos(-1))
			}
			aaparts[i] = eqtest
		}
		andand := makeTermL(AndandExpr, aaparts, TypeBool, Pos(-1), Pos(-1))
		eqsym.binding = makeFuninst(funiscp, funargs, eqsym.dtype, makeScopedTermL(Stmts, bodyscp, []Term{andand}, TypeBool, Pos(-1), Pos(-1)))
		typ.methods.Add(eqsym, 0)
	}
}

// check4Type on TermL handles ortype, tuple, and funtypelit. Make sure the parts TC, then
// handle the rules about ortype variants
func (t *TermL) check4Type(tci *TCInfo) (retval Term) {
	if t.kind == OrtypeLit {
		// t.args is a list of Symdecl, all length 2.
		bpts := make(Bplst, len(t.args))
		var setotypes = make([]*Type, 0, len(t.args))
		for i, symdeclTerm := range t.args {
			symdecl := symdeclTerm.(*TermL)
			idtkn := symdecl.args[0].(*Token)
			typ := TC4Type(symdecl.args[1], nil, tci)
			if typ == nil {
				return tci.Error("type expected", t)
			} else if typ.Tag() == ErrorTag {
				return typ
			}
			typ0 := typ.(*Type)
			bpts[i] = makeSymbol(idtkn.val, typ0, nil)
			// enforce set rule on variant types
			for _, otyp := range setotypes {
				seen := []*Type{}
				if typ0.equal(otyp, &seen) {
					return tci.Error(fmt.Sprintf("type %s occurs twice", typ0.String()), t)
				}
			}
			setotypes = append(setotypes, typ0)
		}
		// at this point, bpts is built and the set rule has been checked. Sort bpts.
		sort.Sort(bpts)
		retval = makeType(TFOrtype, bpts)
	} else if t.kind == TupleTypeLit {
		// t.args is a list of Symdecl, all length 3, 3rd elt indicates privacy.
		var bpts = make([]*Symbol, len(t.args))
		for i, symdeclTerm := range t.args {
			symdecl := symdeclTerm.(*TermL)
			pvt := symdecl.args[2].(*TermB)
			bpt, err := symdecl.TCAttrib(pvt == TrueLiteral, tci)
			if err != nil {
				return err
			}
			bpts[i] = bpt
		}
		retval = makeType(TFTuple, bpts, false)
		synthEqMethod(retval.(*Type), tci)
	} else if t.kind == FunTypeLit {
		// len(t.args) is 2 + #fmlargs; last 2 items are rettype and purity word
		nargs := len(t.args)
		fmlargs := t.args[0 : nargs-2]
		fmltypes := make([]*Type, len(fmlargs))
		for i, a := range fmlargs {
			typ := TC4Type(a, nil, tci)
			if typ.Tag() == ErrorTag {
				return typ
			}
			typ0 := typ.(*Type)
			fmltypes[i] = typ0
		}
		rettyp := TC4Type(t.args[nargs-2], nil, tci)
		if rettyp.Tag() == ErrorTag {
			return rettyp
		}
		rettyp0 := rettyp.(*Type)
		purwd := t.args[nargs-1].(*Token).val
		// parser checked that purwd is "pure" or "mod" but not that rcvr is moddable
		if purwd != "pure" && !(len(fmlargs) > 0 && fmltypes[0].Moddable()) {
			return tci.Error("mod function types must have moddable receiver type", t)
		}
		retval = makeType(TFFtn, fmltypes, rettyp0, purwd == "pure")
	} else if tci.inXprftn && t.kind == IfStmt {
		// this is a highly special case, should be ?: which means both branches and neither is a stmtlist.
		cond := t.args[0].Typecheck(TypeBool, tci)
		if cond.Tag() == ErrorTag {
			return cond
		}
		if len(t.args) == 3 && t.args[1].Tag() != Stmts && t.args[2].Tag() != Stmts {
			tpart := TC4Type(t.args[1], nil, tci)
			epart := TC4Type(t.args[2], nil, tci)
			if tpart.Tag() == ErrorTag {
				return tpart
			}
			if epart.Tag() == ErrorTag {
				return epart
			}
			retval = makeTermL(IfStmt, []Term{cond, tpart, epart}, Gztype, t.first, t.final)
		}
	}
	if retval == nil {
		return tci.Error("cannot interpret this as a type", t)
	}
	return
}

// In the next section, functions or methods that use the traversal protocols

// True if trm contains a call to a mod ftn. Do not go into non-local bindings.
func anyModcall(trm Term) bool {
	var mcWorkfn func(t Term, s interface{}) int
	mcWorkfn = func(t Term, s interface{}) int {
		ret := 0
		tg := t.Tag()
		if tg == SymbolTag {
			seen := s.(*[]*Symbol)
			for _, sn := range *seen {
				if t == sn {
					return 1 // don't probe
				}
			}
			*seen = append(*seen, t.(*Symbol))
		}
		if tg == StmapStmt {
			return 1
		}
		if tg == Funcall {
			if t.(*TermTL).trm.Dtype().isMod() {
				return -1
			}
		} else if tg == Valdecl || tg == Vardecl {
			sym := t.(*TermT).arg0.(*Symbol)
			if TraversePre(sym.binding, mcWorkfn, s) {
				return -1
			}
			ret = 1
		}
		return ret
	}
	seen := make([]*Symbol, 0, 2)
	return TraversePre(trm, mcWorkfn, &seen)
}

// I'm a little bit queasy about defining purity of an expr as not containing a modcall, because an
// asgnmt to something defined outside the scope would also cause observable state change when the expr
// is eval'd. However, such things can be done only on scope fragments within a ftn defn that I believe
// will never come to this ftn.
func isPure(trm Term) bool {
	return !anyModcall(trm)
}

// Generally useful workfn for TraversePre: the state var sv is either a string or a Symbol, and this looks for a Symbol
// in term == s with identifier equal to it. Set up to search in bindings of local defns but not otherwise.
func identWorkfn(trm Term, sv interface{}) int {
	tg := trm.Tag()
	if !(tg == SymbolTag || tg == Valdecl || tg == Vardecl) {
		return 0
	}
	svs, isstrg := sv.(string)
	var sym *Symbol
	if tg == SymbolTag {
		sym = trm.(*Symbol)
	} else {
		sym = trm.(*TermT).arg0.(*Symbol)
	}
	if (isstrg && sym.ident == svs) || (!isstrg && sym == sv.(*Symbol)) {
		return -1
	}
	if tg != SymbolTag && sym.binding != nil && sym.binding.Tag() != TypeTag {
		if TraversePre(sym.binding, identWorkfn, sv) {
			return -1
		}
	}
	return 1
}

// Next, the main attraction: the Typecheck methods. We need these on all
// concrete Term types.

// From parser, this will mostly be IDENT tokens but can also be operators like "in" or "+". The result will usually be
// a Symbol, but could also be a Symchain or ErrorTag Term.
// Note that this doesn't look for types, only entities.
func (t *Token) Typecheck(cntt *Type, tci *TCInfo) Term {
	if tci.inXprftn {
		if cntt == Gztype {
			return TC4Type(t, nil, tci)
		} else if t.val == "_" {
			return matchany
		}
		rwsym, _ := tci.rwstoreScope.Lookup(t.val)
		if rwsym != nil {
			return rwsym
		}
	}
	sym, upcount := tci.scopes.Lookup(t.val)
	if tci.inXprftn && sym != nil {
		if cntt == Gzsym || cntt == Gzterm {
			return sym // any symbol works
		} else if cntt == TypeNothing && anyGenzdType(sym.dtype) {
			return sym
		}
	}
	if sym == nil && cntt != nil && cntt.family == TFFtn {
		// possibly looking for a method of the rcvr
		// I have a feeling there are some other cases I'm missing...
		// todo: figure this out
		funtype := cntt.v.(*Ftntype)
		if len(funtype.fmlargs) > 0 {
			rcvrtype := funtype.fmlargs[0]
			if rcvrtype.family == TFGTS {
				gtssym := rcvrtype.v.(*GTS)
				if gtssym.binding != nil {
					rcvrtype = gtssym.binding
				}
			}
			inx := rcvrtype.methodIndex(t.val)
			if inx >= 0 {
				sym = rcvrtype.methods[inx].sym
			}
		}
	}
	seen := []*Type{}
	if sym != nil {
		for upc := -1; ; {
			symtyp := sym.dtype
			var symterm Term = sym
			if symtyp.isNilposs() && !tci.inLval {
				symterm = tci.tryGuardfixNP(sym)
				symtyp = symterm.Dtype()
			} else if symtyp.family == TFOrtype { // check for tag guarding
				gdi := tci.findTagGuard(sym)
				if gdi != nil {
					vnts := symtyp.v.(*Ortype).variants
					if gdi.pos {
						symtyp = vnts[gdi.kind-2].dtype
					} else if len(vnts) == 2 {
						symtyp = vnts[3-gdi.kind].dtype
					} else {
						// synthesize an ortype with the guarded variant deleted
						vnts0 := make([]*Symbol, len(vnts)-1)
						inx := gdi.kind - 2
						copy(vnts0, vnts[:inx])
						copy(vnts0[inx:], vnts[inx+1:])
						symtyp = makeType(TFOrtype, vnts0)
					}
					symterm = makeTermT(Gdref, sym, symtyp, Pos(-1), Pos(-1))
				}
			} else if symtyp.family == TFTypred {
				if tci.findTypredGuard(sym) != nil {
					return makeTermT(Gdref, sym, tci.typecaseType, t.pos, t.pos)
				}
			} else if cntt == TypeByte && symtyp == TypeInt && sym.plist.Find("var") == nil {
				if sym.binding.Tag() == Intlit {
					iv := sym.binding.Plist().Find("intval").(int)
					if iv >= 0 && iv < 256 {
						return makeTermT(Gdref, sym, TypeByte, t.pos, t.pos)
					}
				}
			}
			if cntt == nil || symtyp.compat(cntt, &seen) {
				return symterm
			}
			if cntt == TypeByte && sym.dtype == TypeInt {
				bdg, ok := sym.binding.(*TermB)
				if ok {
					iv := bdg.plist.Find("intval").(int)
					if iv >= 0 && iv < 256 {
						return t
					}
				}
			} else {
				cvtd := tryAutocvt(symtyp, cntt, tci)
				if cvtd != nil {
					return makeFuncall(cvtd, []Term{sym}, cvtd.dtype.v.(*Ftntype).rettype, nil)
				}
			}
			upc++
			if upc == upcount {
				break
			}
			sym = tci.scopes.LookupN(t.val, upc)
			seen = seen[0:0]
		}
	} else {
		// check if t.val is an implicit attref of a "self" or "this" symbol. Note that multibdg doesn't apply here.
		var try = func(pronoun string) Term {
			sym, _ = tci.scopes.Lookup(pronoun)
			if sym != nil {
				atrb := sym.dtype.attributeLookup(t.val)
				if atrb != nil {
					var symchain Term = makeSymchain([]Term{sym, atrb}, atrb.dtype, t.First(), t.Final())
					tci.trySymchainfixNP(symchain.(*TermL))
					symtyp := symchain.Dtype()
					if symtyp.family == TFOrtype && !symtyp.v.(*Ortype).isNilposs {
						// could be tag guard
						gdi := tci.findTagGuard(symchain)
						if gdi != nil {
							vnts := symtyp.v.(*Ortype).variants
							if gdi.pos {
								symtyp = vnts[gdi.kind-2].dtype
							} else if len(vnts) == 2 {
								symtyp = vnts[3-gdi.kind].dtype
							} else {
								// synthesize an ortype with the guarded variant deleted
								vnts0 := make([]*Symbol, len(vnts)-1)
								inx := gdi.kind - 2
								copy(vnts0, vnts[:inx])
								copy(vnts0[inx:], vnts[inx+1:])
								symtyp = makeType(TFOrtype, Bplst(vnts0))
							}
							symchain = makeTermT(Gdref, symchain, symtyp, Pos(-1), Pos(-1))
						}
					}
					if cntt == nil || symchain.Dtype().compat(cntt, &seen) {
						return symchain
					}
					if cntt != nil {
						acfn := tryAutocvt(symchain.Dtype(), cntt, tci)
						if acfn != nil {
							return makeFuncall(acfn, []Term{symchain}, acfn.dtype.v.(*Ftntype).rettype, nil)
						}
					}
				}
			}
			return nil
		}
		implicit := try("this")
		if implicit == nil {
			implicit = try("self")
		}
		if implicit != nil {
			return implicit
		}
	}
	msg := fmt.Sprintf("can't find a symbol named %s", t.val)
	if cntt != nil {
		if t.val == "nil" {
			msg = fmt.Sprintf("'nil' can't have type %s", cntt.String())
		} else {
			msg = fmt.Sprintf("can't find a symbol named %s with type %s", t.val, cntt.String())
		}
	}
	return tci.Error(msg, t)
}

// Mostly, Symbols are created by TC, so this checks but normally changes nothing.
func (t *Symbol) Typecheck(cntt *Type, tci *TCInfo) Term {
	if cntt != nil {
		seen := []*Type{}
		if !t.dtype.compat(cntt, &seen) {
			if cntt == TypeByte && t.dtype == TypeInt {
				bdg, ok := t.binding.(*TermB)
				if ok {
					iv := bdg.plist.Find("intval").(int)
					if iv >= 0 && iv < 256 {
						return t
					}
				}
			}
			return tci.ErrorExpect(cntt, t.dtype, t)
		}
	}
	return t
}

// Basic literals; check against cntt and otherwise return as is.
// Exception made for Errors, just pass these on
func (t *TermB) Typecheck(cntt *Type, tci *TCInfo) Term {
	if t.kind == ErrorTag {
		return t
	}
	seen := []*Type{}
	if t.kind == Labellit && cntt != nil {
		inx := indexELT(cntt, t.value)
		if inx >= 0 {
			// make an intlit tagged so as to retain ELT type info
			intlit := makeIntlit(inx)
			intlit.plist.Add("ELType", cntt)
			return intlit
		}
		//t.plist.Add("labeltype", cntt)
		//return t
	}
	var t0 Term = t
	if t.kind == Stringlit && t.plist.Find("isRaw").(bool) == false {
		// check for interpolation
		i := 0
		var bldr strings.Builder
		// in sprintf args, leave room at the front for fmtg string
		sprintfArgs := make([]Term, 1, 3)
		for {
			inx := strings.Index(t.value[i:], "#")
			if inx < 0 {
				if len(sprintfArgs) > 1 && i < len(t.value) {
					bldr.WriteString(t.value[i:])
				}
				break
			}
			if len(t.value) > i+inx+1 && t.value[i+inx+1] == '{' {
				bldr.WriteString(t.value[i : i+inx])
				// we've got an interpolation: scan for end, parse expr, etc.
				// Note that this can't handle exprs with braces; noted as a bug
				endinx := strings.Index(t.value[i+inx:], "}")
				if endinx < 0 {
					return tci.Error("missing close brace", t)
				}
				parser := setupStringParser(t.value[i+inx+2:i+inx+endinx+1], false)
				expr := parser.expr(0)
				if expr.Tag() == ErrorTag {
					return expr
				}
				uncnttd := expr.Typecheck(nil, tci)
				if uncnttd.Tag() == ErrorTag {
					return uncnttd
				}
				xprtyp := uncnttd.Dtype()
				if xprtyp != TypeString {
					stgfy := xprtyp.stringifyMethod(nil)
					uncnttd = makeFuncall(stgfy, []Term{uncnttd}, TypeString, t)
				}
				sprintfArgs = append(sprintfArgs, uncnttd)
				bldr.WriteString("%s")
				postexpr := parser.nxToken()
				if postexpr.code != RBRACE {
					return tci.Error("missing brace or extra tokens after expression in #{...}", t)
				}
				// RBRACE length is 1 and we started at inx+2
				i += inx + int(postexpr.pos) + 3
			} else {
				i += inx + 1
			}
		}
		if len(sprintfArgs) > 1 {
			sprintfArgs[0] = makeStringTerm(bldr.String(), Pos(-1), false)
			t0 = makeFuncall(biScope["__sprintf"][0], sprintfArgs, TypeString, t)
		}
	}
	if !t0.Dtype().compat(cntt, &seen) {
		if (cntt == TypeByte || cntt == TypeUint8) && t.kind == Intlit {
			iv := t.plist.Find("intval").(int)
			if iv >= 0 && iv < 256 {
				return t
			}
		}
		if cntt != nil {
			acfn := tryAutocvt(t0.Dtype(), cntt, tci)
			if acfn != nil {
				return makeFuncall(acfn, []Term{t0}, acfn.dtype.v.(*Ftntype).rettype, nil)
			}
		}
		return tci.ErrorExpect(cntt, t0.Dtype(), t)
	}
	return t0
}

// tcDecl receives Symdecl-like args from a val or var termL and processes it, returning the resulting Symbol
// or an error and modding the local scope in tci if the decl succeeds.
// Note that the caller will process the Symbol into the val or var Term in success case.
func (t *TermL) tcDecl(tci *TCInfo, isVar bool) Term {
	var addType = func(scp *Scope, typsym *Symbol) Term {
		if isVar {
			return tci.Error("you cannot declare a type with 'var'", t)
		}
		if typsym.binding != nil && !tci.inXprftn {
			typ := typsym.binding.(*Type)
			typ.plist.Add("typename", typsym.ident)
		}
		typsymx, strg := scp.AddIfPossible(typsym)
		if strg == "" {
			return typsymx
		} else {
			return tci.Error(strg, t)
		}
	}
	idtkn := t.args[0].(*Token)
	//if idtkn.val == "olist" {
	//	fmt.Print()
	//}
	givencxt := tci.cxt.FindItem("givenscope") // will be nil or a *Scope
	destscope := tci.scopes
	if givencxt != nil {
		destscope = destscope.parent // don't add to the givenscope but its parent
	}
	var sym *Symbol
	var cntt0 *Type
	if t.args[1] != nil { // check type = "type" else infer as type and use as cntt for rhs.
		asTkn, isTkn := t.args[1].(*Token)
		if isTkn && asTkn.val == "type" { // this case disposes and returns.
			if tci.inXprftn && t.args[2] == nil {
				// declg a type-valued matchable
				sym = makeSymbol(idtkn.val, Gztype, nil)
				symx, strg := destscope.AddIfPossible(sym)
				if strg != "" {
					return tci.Error(strg, t)
				}
				if isVar {
					symx.plist.Add("var", true)
				}
				return symx
			} else {
				// normally, a type-valued symbol but can be declg unbound type symbol
				var rhsT Term = makeType(TFUnknown)
				tidsym := makeSymbol(idtkn.val, nil, rhsT)
				if t.args[2] == nil {
					tidsym.binding = rhsT
				} else {
					tci.pushTypeInDef(tidsym)
					rhsT = TC4Type(t.args[2], nil, tci)
					if rhsT.Tag() == TypeTag && itemExists(tidsym.binding, "rectypeMentioned") {
						// this means the typeInDef was mentioned recursively, so we need to replace rhsT with it.
						tmpt := tidsym.binding.(*Type)
						rhsT0 := rhsT.(*Type)
						tmpt.family = rhsT0.family
						tmpt.v = rhsT0.v
						tmpt.methods = rhsT0.methods
						tmpt.plist = rhsT0.plist
						tmpt.asserts = rhsT0.asserts
						tmpt.handlers = rhsT0.handlers
						tmpt.SetString()
						rhsT = tmpt
					}
					tci.popTypeInDef()
					if rhsT.Tag() == ErrorTag {
						return rhsT
					}
					if rhsT.Tag() == SymbolTag {
						rhsT = rhsT.(*Symbol).binding
					}
					tidsym.binding = rhsT
				}
				return addType(destscope, tidsym)
			}
		}
		// here, parse the type and save it for use below.
		if t.args[1].Tag() == Ident && tci.typeInDef != nil && tci.typeInDef.ident == t.args[1].(*Token).val {
			// special case refnc to type being defined
			cntt0 = tci.typeInDef.binding.(*Type)
		} else {
			cnttTrm := TC4Type(t.args[1], nil, tci)
			if cnttTrm.Tag() == ErrorTag {
				return cnttTrm
			}
			cntt0 = cnttTrm.(*Type)
		}
	}
	// At this point, there's a remote possibility that rhs == nil in which case
	// it's an error for cntt to be nil. If rhs is nil and cntt != nil, create and
	// intern an unbound Symbol.
	if t.args[2] == nil {
		if cntt0 == nil {
			lrstrg := "val"
			if isVar {
				lrstrg = "var"
			}
			msg := fmt.Sprintf("%s stmt is missing both type and binding", lrstrg)
			return tci.Error(msg, t)
		}
		sym = makeSymbol(idtkn.val, cntt0, nil)
		if givencxt != nil {
			sym.plist.Add("givenscope", givencxt)
		}
		if isVar {
			sym.plist.Add("var", true)
		}
		symx, strg := destscope.AddIfPossible(sym)
		if strg == "" {
			if !isVar && symx.dtype.family == TFFtn {
				symx.plist.Add("fwddecld", true)
			}
			return symx
		} else {
			return tci.Error(strg, t)
		}
	}
	// If we've got both rhs and cntt, check the former cnttd by the latter. Else
	// rhs != nil and cntt == nil. In this case, the rhs might be a type.
	// First, check (and favor) this possibility; if plausible, return the result
	// of that analysis. Otherwise, infer the type from rhs.
	rhs := t.args[2]
	if cntt0 == nil {
		// This switch is going to investigate all the options for rhs as a type.
		switch rhs0 := rhs.(type) {
		case *Token: // type accessed by name; create an alias.
			typsym := tci.scopes.lookupType(rhs0.val)
			if typsym != nil {
				return addType(destscope, makeSymbol(idtkn.val, nil, typsym.binding))
			}
		case *TermTL: // typegen "call"
			var tgityp Term
			if rhs0.kind == Funcall && rhs0.trm.Tag() == Ident {
				tgtkn := rhs0.trm.(*Token)
				// ELT decls are hard coded to "label"; otherwise, a type-valued funcall involves a Typegen.
				if tgtkn.val == "label" || tgtkn.val == "type" {
					// here, we know there's a typegen interpn; commit to it, using TC4Type
					tgityp = funcallTypeSpecial(rhs0, tgtkn.val, tci)
				}
			}
			if tgityp == nil && rhs0.kind == Funcall && findTypegen(rhs0.trm, tci) != nil {
				tgityp = rhs0.check4Type(tci)
			}
			if tgityp != nil {
				if tgityp.Tag() == ErrorTag {
					return tgityp
				}
				return addType(destscope, makeSymbol(idtkn.val, nil, tgityp))
			}
		case *TermL: // ortype, tuple, function
			if rhs0.kind == OrtypeLit || rhs0.kind == TupleTypeLit || rhs0.kind == FunTypeLit {
				rhsT := rhs0.check4Type(tci)
				if rhsT.Tag() == ErrorTag {
					return rhsT
				}
				return addType(destscope, makeSymbol(idtkn.val, nil, rhsT))
			}
		case *TermTT:
			if rhs0.kind == ExtendExpr {
				var tidsym *Symbol
				placeholder := tci.scopes.lookupType(idtkn.val)
				if placeholder != nil && placeholder.binding.(*Type).family == TFUnknown {
					tidsym = placeholder
				} else {
					tidsym = makeSymbol(idtkn.val, nil, nil)
				}
				tci.pushTypeInDef(tidsym)
				defer tci.popTypeInDef()
				rhsT := TC4Type(rhs0, nil, tci)
				if rhsT.Tag() == ErrorTag {
					return rhsT
				}
				return addType(destscope, tidsym)
			}
		}
	}
	// At this point, we know the rhs isn't a type, so we're going to TC for an entity and cntt0 is the cntt we want.
	// Except that we'll do something a bit different if there's no type and rhs is a ftnlit with
	// default args. Because internally, we're going to rep that as a bunch of Symbols, each bound to its
	// own Funinst. A special version of tcFunlit generates these.
	if cntt0 == nil && rhs.Tag() == FunLit {
		rhs0 := rhs.(*TermL)
		nargs := len(rhs0.args) - 3 // number of funargs
		purwd := rhs0.args[nargs+1].(*Token)
		if purwd.val != "typegen" && purwd.val != "xprftn" {
			// so far so good. Now check if there are defaulted args.
			defaults := false
			for _, a := range rhs0.args[0:nargs] {
				if len(a.(*TermL).args) == 4 {
					defaults = true
					break
				}
			}
			if defaults {
				flwdret := rhs0.tcFunlitWithDefaulted(idtkn.val, tci)
				allSyms, ok := flwdret.([]*Symbol)
				if ok {
					for i, sym := range allSyms {
						if givencxt != nil {
							sym.plist.Add("givenscope", givencxt)
						}
						symx, strg := destscope.AddIfPossible(sym)
						if strg != "" {
							return tci.Error(strg, t)
						}
						allSyms[i] = symx
					}
					return allSyms[0]
				} else {
					return flwdret.(Term) // will be ErrorTag *TermB
				}
			}
		}
	}
	// similarly, we treat a typepred binding specially
	if rhs.Tag() == TypepredExpr {
		sym0 := rhs.(*TermL).tcTypred(tci, idtkn.val)
		if sym0.Tag() == ErrorTag {
			return sym0
		}
		sym = sym0.(*Symbol)
	} else {
		// finally, we get to the normal case where we're TC'g an entity and (probably) inferring its type
		// Note that cntt0 might have been set earlier. Also, we set up a special slot for recursive ftns if
		// the rettype is explicit in the ftnlit. Actually, the recursion check is a bit more complicated to
		// accomodate defining mutually recursive ftns. You do this in d8m by defining a ftn symbol without a
		// binding, then with one. Other refncs to the symbol will TC without noticing it's unbound. If now
		// we're defining the unbound one, we need to smash its binding with the upcoming Funlit so that the
		// other mutually recursive definitions have the correct Symbol.
		recursionOk := false
		if rhs.Tag() == FunLit {
			rhs0 := rhs.(*TermL)
			nargs := len(rhs0.args)
			if rhs0.args[nargs-3] != nil {
				recursionOk = true
				sym, _ = tci.scopes.Lookup(idtkn.val)
				if sym == nil || sym.dtype == nil || sym.binding != nil || sym.dtype.family != TFFtn {
					sym = makeSymbol(idtkn.val, nil, nil)
				}
				tci.ftnInDef = append(tci.ftnInDef, sym)
			}
		} else if tci.inXprftn && generalizedType(cntt0) {
			// check to see if it's a PEM
			var isMatcher = func(nm string) bool {
				return nm == "match" || nm == "matches" || nm == "contains" || nm == "matchcount" || nm == "matching"
			}
			if rhs.Tag() == Funcall && rhs.(*TermTL).trm.Tag() == Ident {
				fnm := rhs.(*TermTL).trm.(*Token).val
				if isMatcher(fnm) {
					ptn := rhs.Typecheck(nil, tci)
					if ptn.Tag() == ErrorTag {
						return ptn
					}
					sym = makeSymbol(idtkn.val, cntt0, ptn)
					symx, strg := destscope.AddIfPossible(sym)
					if strg != "" {
						return tci.Error(strg, t)
					}
					return symx
				}
			}
		}
		entx := rhs.Typecheck(cntt0, tci)
		if cntt0 != nil && len(cntt0.methods) > len(entx.Dtype().methods) {
			// Special handling for the case that an explicit type is a method augmentation of the inferred one
			// Create an "automatic autocvt" for it.
			// todo: apply the same strategy to cast
			autoautoType := makeType(TFFtn, []*Type{entx.Dtype()}, cntt0, true)
			aafuni := makeFuninst(nil, nil, autoautoType, nil)
			entx = makeFuncall(makeSymbol("autocvt", autoautoType, aafuni), []Term{entx}, cntt0, nil)
		}
		if recursionOk {
			tci.ftnInDef = tci.ftnInDef[0 : len(tci.ftnInDef)-1]
			if entx.Tag() == FuninstTag && sym.plist.Find("recursive") != nil {
				// This really belongs on the Funinst so we copy it.
				entx.Plist().Add("recursive", true)
			}
		}
		if entx.Tag() == ErrorTag {
			return entx
		}
		if sym == nil {
			if cntt0 == nil {
				cntt0 = entx.Dtype()
				// this is slightly too conservative: cntt0 might be a label bound to a value but if it's a var, it may change
				if isVar && cntt0.family == TFLabel {
					cntt0 = TypeLabel
				}
			}
			sym = makeSymbol(idtkn.val, cntt0, nil)
			if tci.inXprftn && callingNamed(rhs, "pattern") {
				sym.dtype = Gzptn
			}
		} else {
			sym.dtype = entx.Dtype()
		}
		sym.binding = entx
		if entx.Tag() == TypegenTag {
			tg := entx.(*Typegen)
			tg.plist.Add("typegenName", &struct {
				nm    string
				count int
			}{idtkn.val, 0})
			if givencxt != nil {
				tg.plist.Add("givenscope", givencxt)
			}
		} else if givencxt != nil {
			sym.plist.Add("givenscope", givencxt)
		}
		if isVar {
			sym.plist.Add("var", true)
		}
		// check some things about ftns; the dtype check filters typegens and the like
		if rhs.Tag() == FunLit && sym.dtype != nil {
			if itemExists(entx, "connected") {
				sym.plist.Add("connected", true)
			}
		}
	}
	symx, strg := destscope.AddIfPossible(sym)
	if strg != "" {
		return tci.Error(strg, t)
	}
	return symx
}

// Typecheck for val, var, assert, break, continue, loop, return, unary-, !. Note that break and continue
// always set arg0 to nil; that's optional with return.
func (t *TermT) Typecheck(cntt *Type, tci *TCInfo) Term {
	if t.dtype != nil {
		seen := []*Type{}
		if !(cntt == nil || t.dtype.compat(cntt, &seen)) {
			return tci.ErrorExpect(cntt, t.dtype, t)
		}
		return t
	}
	tci.RecordBackup(t)
	switch t.kind {
	case Valdecl, Vardecl:
		if t.dtype == TypeNothing {
			return t // already checked
		}
		seen := []*Type{}
		if !(cntt == nil || cntt.equal(TypeNothing, &seen)) {
			return tci.ErrorExpect(cntt, TypeNothing, t)
		}
		symdecl := t.arg0.(*TermL)
		ret := symdecl.tcDecl(tci, t.kind == Vardecl)
		if ret.Tag() == ErrorTag {
			return ret
		} else {
			t.arg0 = ret
			retsym := ret.(*Symbol)
			if retsym.binding == nil && retsym.plist.Find("var") == nil && retsym.dtype.family == TFFtn {
				t.kind = Fwddecl
			}
			t.dtype = TypeNothing
			triggered := defConds.update4Defn(ret.(*Symbol))
			if triggered != nil {
				for _, bod := range triggered {
					// interpret the stmts of bod directly, otherwise actions may get attached to the bod stmtlist's scope
					// instead of the scope we're really in right now.
					for _, stmt := range bod.(*TermL).args {
						rslt := stmt.Typecheck(nil, tci)
						if rslt.Tag() == ErrorTag {
							return rslt
						}
					}
				}
			}
			return t
		}
	case Lognot:
		argtag := t.arg0.Tag()
		if argtag == Lognot {
			a0 := t.arg0.(*TermT)
			return a0.arg0.Typecheck(cntt, tci)
		}
		// demorganize && and || if they've got ! on the outside
		if argtag == AndandExpr || argtag == OrorExpr {
			andx := t.arg0.(*TermL)
			fliptag := OrorExpr
			if andx.kind == OrorExpr {
				fliptag = AndandExpr
			}
			clauses := make([]Term, len(andx.args))
			for i, a := range andx.args {
				clauses[i] = makeTermT(Lognot, a, nil, andx.first, andx.final)
			}
			return makeTermL(fliptag, clauses, nil, t.first, t.final).Typecheck(cntt, tci)
		}
		// because of demorganizing the above, it's possible that recursively, we see !(x = y)
		// that's actually possible just because some strange programmer wrote it that way, or some
		// rewrite rule. For TC purposes, it's better to rewrite those into the direct oprs, which we do next.
		if argtag == EqExpr || argtag == EqeqExpr {
			fliptag := NeqExpr
			if argtag == EqeqExpr {
				fliptag = NeqeqExpr
			}
			a0 := t.arg0.(*TermTT)
			return makeTermTT(fliptag, a0.arg0, a0.arg1, nil, t.first, t.final).Typecheck(cntt, tci)
		} else if argtag == NeqExpr || argtag == NeqeqExpr {
			fliptag := EqExpr
			if argtag == NeqeqExpr {
				fliptag = EqeqExpr
			}
			a0 := t.arg0.(*TermTT)
			return makeTermTT(fliptag, a0.arg0, a0.arg1, nil, t.first, t.final).Typecheck(cntt, tci)
		}
		// finally, we're ready to TC the normal case for Lognot
		if cntt != nil && cntt != TypeBool {
			return tci.Error("! is always boolean", t)
		}
		a0 := t.arg0.Typecheck(cntt, tci)
		if a0.Tag() == ErrorTag {
			return a0
		} else {
			t.arg0 = a0
			t.dtype = TypeBool
		}
	case Negate:
		if t.arg0.Tag() == Negate {
			a0 := t.arg0.(*TermT)
			return a0.arg0.Typecheck(cntt, tci)
		}
		a0 := t.arg0.Typecheck(nil, tci)
		if a0.Tag() == ErrorTag {
			return a0
		} else {
			if !(cntt == nil) {
				a0t := a0.Dtype()
				seen := []*Type{}
				if !a0t.compat(cntt, &seen) {
					return tci.Error("unary - requires a numeric argument", t)
				}
			}
			t.arg0 = a0
			t.dtype = t.arg0.Dtype()
		}
	case BreakStmt, ContinueStmt:
		tgstrg := "break"
		if t.kind == ContinueStmt {
			tgstrg = "continue"
		}
		if cntt != nil && cntt != TypeNothing {
			return tci.ErrorExpectStmt(tgstrg, cntt, t)
		}
		inx := tci.cxt.Find(LoopStmt, 0, NoTerm)
		if inx < 0 {
			inx = tci.cxt.Find(EachStmt, 0, NoTerm)
		}
		if inx < 0 {
			return tci.ErrorCxt(tgstrg, "loop", t)
		}
		tci.exitstmt = true // signal to tci.ExitGuardingCxt
		tci.exitHere = true // signal to enclosing stmtlist processing
		t.dtype = TypeNothing
	case ReturnStmt:
		// the cntt is tricky here. Usually, stmts other than the last in a stmtlist should be nothing-valued.
		// But that's not true for return. The current solution is to clear nothing to nil (aka don't care) and
		// then set it from the FunLit if the signature has a rettype.
		if cntt == TypeNothing {
			cntt = nil
		}
		inx := tci.cxt.Find(FunLit, 0, NoTerm)
		// since t is returned (modded), the funlit code will be able to see what's done here
		if inx < 0 {
			return tci.ErrorCxt("return", "function", t)
		} else {
			tci.cxt.AccumTagAt(inx, "returns", t)
			retcntt := tci.cxt.FindItem("retcntt")
			if retcntt != nil && (cntt == nil || cntt.family == TFNothing) {
				cntt = retcntt.(*Type)
			}
		}
		tci.exitstmt = true // signal to tci.ExitGuardingCxt
		tci.exitHere = true // signal to enclosing stmtlist processing
		if t.arg0 == nil {
			t.dtype = TypeNothing
		} else {
			a0 := t.arg0.Typecheck(cntt, tci)
			if a0.Tag() == ErrorTag {
				return a0
			} else {
				t.arg0 = a0
				t.dtype = a0.Dtype()
			}
		}
	case LoopStmt:
		if cntt != nil && cntt != TypeNothing {
			return tci.ErrorExpectStmt("loop", cntt, t)
		}
		tci.cxt.Push(t.kind)
		a0 := t.arg0.Typecheck(TypeNothing, tci)
		tci.cxt.Pop()
		if a0.Tag() == ErrorTag {
			return a0
		} else {
			t.arg0 = a0
			t.dtype = TypeNothing
		}
	case AssertStmt:
		if cntt != nil && cntt != TypeNothing {
			return tci.ErrorExpectStmt("assert", cntt, t)
		}
		tci.cxt.Push(t.kind)
		a0 := t.arg0.Typecheck(TypeBool, tci)
		tci.cxt.Pop()
		if a0.Tag() == ErrorTag {
			return a0
		}
		// EAPs (like enumerable) handle the side effects and return a __EAP symbol; ignore those
		if !symbolNamed(a0, "__EAP") {
			tci.asserted(a0)
		}
		t.arg0 = a0
		t.dtype = TypeNothing
	case Gdref:
		seen := []*Type{}
		if !(cntt == nil || t.dtype.compat(cntt, &seen)) {
			return tci.ErrorExpect(cntt, t.dtype, t)
		}
	default: // unary neg, maybe not much else...
		a0 := t.arg0.Typecheck(cntt, tci)
		if a0.Tag() == ErrorTag {
			return a0
		} else {
			t.arg0 = a0
			t.dtype = a0.Dtype()
		}
	}
	return Simplify(t)
}

// Process the extend expr. Assumes t.Tag() == ExtendExpr.
func (t *TermTT) tcExtend(tci *TCInfo) Term {
	basetype0 := TC4Type(t.arg0, nil, tci)
	if basetype0.Tag() == ErrorTag {
		return basetype0
	}
	basetype := basetype0.(*Type)
	nonxTFS := []TypeFamily{TFNil, TFNothing, TFFtn, TFBool, TFBit, TFByte, TFTime, TFBaseQty, TFQtyRatio}
	for _, tf := range nonxTFS {
		if basetype.family == tf {
			return tci.Error(fmt.Sprintf("basetype %s cannot be extended", typeFamilyStrings[tf]), t)
		}
	}
	var btcopy *Type
	if tci.typeInDef != nil && tci.typeInDef.binding != nil {
		btcopy = tci.typeInDef.binding.(*Type)
		btcopy.family = basetype.family
		btcopy.v = basetype.v
		btcopy.methods = basetype.methods
		btcopy.plist = basetype.plist
		btcopy.asserts = basetype.asserts
		btcopy.handlers = basetype.handlers
		btcopy.SetString()
	} else {
		btcopy = basetype.Copy().(*Type)
		if tci.typeInDef != nil {
			tci.typeInDef.binding = btcopy
		}
	}
	btcopy.plist.Delete("typename")
	btcopy.SetString()
	// before pushing our own cxt, look for the condition enabling this to be a nested type defn using "outer" gnc symbols
	outerExtend := tci.cxt.Find(ExtendExpr, 0, NoTerm)
	inTypegen := len(*tci.cxt)
	var params *Scope
	for {
		inTypegen = tci.cxt.Find(FunLit, len(*tci.cxt)-inTypegen, NoTerm)
		if inTypegen < 0 {
			break
		}
		params0 := (*tci.cxt)[inTypegen].plist.Find("typegen")
		if params0 != nil {
			params = params0.(*Scope)
			break
		}
	}
	// if outerExtend >= 0 and params != nil, the nested situation is in play
	tyscope := makeScope()
	btcopy.selfsym = makeSymbol("self", btcopy, nil)
	tyscope.Add(btcopy.selfsym, 0)
	tci.PushScope(tyscope)
	tci.cxt.Push(t.kind)
	tci.cxt.SetItem("basetype", btcopy)
	// first check that body contains only legit stmts
	xtndtags := []Termtag{Methoddecl, MethoddeclPvt, Valdecl, Attribdecl, AttribdeclPvt, AssertStmt, OncondStmt, OntimeStmt}
	stmts := t.arg1.(*TermL) // parser ensures this works
	for _, s := range stmts.args {
		found := false
		for _, xtg := range xtndtags {
			if s.Tag() == xtg {
				found = true
				break
			}
		}
		if !found {
			return tci.Error(fmt.Sprintf("%s statement may not occur in extend", s.String()), t)
		}
	}
	// now, we know TC will see only the above tags.
	body := stmts.Typecheck(nil, tci)
	tci.cxt.Pop()
	tci.PopScope()
	if body.Tag() == ErrorTag {
		return body
	}
	// Handle a subtle problem with local fn defns
	extendedLocals := make([]*Symbol, 0, 2)
	for _, symx := range body.(*TermL).scope.entries {
		bdg := symx.sym.binding
		if bdg.Tag() != TypeTag && bdg.Dtype().family == TFFtn {
			// check local fn defns for use of btcopy.selfsym. These are hard to handle because CG flattens scoping in d8m defn
			funi := bdg.(*Funinst)
			if TraversePre(funi.body, identWorkfn, btcopy.selfsym) {
				funi.funargs = append(funi.funargs, btcopy.selfsym)
				extendedLocals = append(extendedLocals, symx.sym)
			}
		}
	}
	if len(extendedLocals) > 0 {
		// Here we've fixed a local with a nonlocal refnc to btcopy.selfsym by adding it as an additional arg. To make
		// this work, we need to find call points of these fns and supply them with actuals. These should be args named self.
		type addArgT = struct {
			localfn *Symbol
			selfarg *Symbol
		}
		var addArgWF func(trm Term, stvar interface{}) int
		addArgWF = func(trm Term, stvar interface{}) int {
			tg := trm.Tag()
			if tg == SymbolTag {
				return 1
			} else if tg == Valdecl || tg == Vardecl {
				decl := trm.(*TermT).arg0.(*Symbol)
				if decl.binding != nil {
					return addArgWF(decl.binding, stvar)
				}
			} else if tg == Funcall {
				stvar0 := stvar.(*addArgT)
				fcall := trm.(*TermTL)
				if fcall.trm == stvar0.localfn {
					fcall.args = append(fcall.args, stvar0.selfarg)
				}
			}
			return 0
		}
		for _, mthdx := range btcopy.methods {
			mfunc := mthdx.sym.binding.(*Funinst)
			for _, xl := range extendedLocals {
				TraversePre(mfunc, addArgWF, &addArgT{xl, mfunc.funargs[0]})
			}
		}
		// Note: in theory we should do this for local fns too... todo: fix this (obscure) bug
	}
	// check for a special problem with lithooks
	if btcopy.family == TFTuple {
		hasListLH := false
		lhcount := 0
		for _, m := range btcopy.methods {
			if m.sym.ident == "lithook" {
				lhcount++
				ft := m.sym.dtype.v.(*Ftntype)
				if len(ft.fmlargs) == 2 && ft.fmlargs[1].family == TFList {
					hasListLH = true
					break
				}
			}
		}
		if hasListLH && lhcount > 1 {
			return tci.Error("a list-accepting lithook must be the only lithook method", t)
		}
	}
	// also, enforce the cntt that a method named "<" induces one named "<="
	ltinx := -1
	leinx := -1
	for i, m := range btcopy.methods {
		if m.sym.ident == "<" {
			ltinx = i
		}
		if m.sym.ident == "<=" {
			leinx = i
		}
	}
	if ltinx >= 0 && leinx < 0 { // synthesize <=
		var lefuni *Funinst
		ltsym := btcopy.methods[ltinx].sym
		lemthd := makeSymbol("<=", ltsym.dtype, nil)
		if ltsym.binding != nil {
			ltfuni := ltsym.binding.(*Funinst)
			// now let's make the body of <=
			ltbody := ltfuni.body
			lefunargs := ltfuni.funargs
			lebody := makeScopedTermL(Stmts, makeScope(), make([]Term, 0, 1), TypeBool, Pos(-1), Pos(-1))
			// if < is A < B for A and B exprs (presumably symchains) then synth A <= B
			if len(ltbody.args) == 1 && callingNamed(ltbody.args[0], "<") {
				ltcall := ltbody.args[0].(*TermTL)
				ltargt := ltcall.args[0].Dtype()
				lemthd := ltargt.methods.Find("<=") // has to be there
				if lemthd == nil {
					panic("<= method expected")
				}
				lebody.args = append(lebody.args, makeFuncall(lemthd, []Term{ltcall.args[0], ltcall.args[1]}, TypeBool, nil))
			} else {
				// Nope, too complicated. Synth as A < B || A == B
				a1 := makeSymbol(gensym(), lefunargs[0].dtype, nil)
				a2 := makeSymbol(gensym(), lefunargs[1].dtype, nil)
				lefunargs = []*Symbol{a1, a2}
				ltcall := makeFuncall(ltsym, []Term{a1, a2}, TypeBool, nil)
				eqcall := makeTermTT(EqExpr, a1, a2, TypeBool, Pos(-1), Pos(-1))
				lebody.args = append(lebody.args, makeTermL(OrorExpr, []Term{ltcall, eqcall}, TypeBool, Pos(-1), Pos(-1)))
			}
			lefuni = makeFuninst(ltfuni.scope, lefunargs, ltfuni.dtype, lebody)
		}
		lemthd.binding = lefuni
		btcopy.methods.Add(lemthd, 0)
	}
	// assertions already done but add handlers
	for _, stmt := range body.(*TermL).args {
		tg := stmt.Tag()
		if tg == OncondStmt || tg == OntimeStmt {
			panic("unwritten")
		}
	}
	if outerExtend >= 0 && params != nil {
		gncs := btcopy.genericsInMethods()
		nei := false // check for "non-empty intersection"
		for _, prm := range params.entries {
			for _, gnc := range gncs {
				if prm.sym.binding != nil && prm.sym.binding.(*Type) == gnc {
					nei = true
					break
				}
			}
		}
		if nei {
			btcopy.plist.Add("nestedGnc", gncs)
		}
	}
	return btcopy
}

// synthFilt is a helper for the IndexExpr case of TermTT.Typecheck.
// It creates and returns an un-typechecked Term corresponding to either filt1 or filt1x, depending on whether the
// xfm arg is nil or not. This needs to be TC'd by the caller.
func synthFilt(lhs Term, pred Term, xfm Term, tci *TCInfo, t *TermTT) Term {
	eltyp := lhs.Dtype().Elttype()
	if eltyp == nil {
		return tci.Error("left operand of filt1 is not enumerable", t)
	}
	thissym := makeSymbol("this", eltyp, nil)
	inxsym := makeSymbol("index", TypeInt, nil)
	body := makeScopedTermL(Stmts, makeScope(), []Term{pred}, nil, Pos(-1), Pos(-1))
	synthdpred := makeTermL(FunLit, []Term{thissym, inxsym, nil, SynthToken(IDENT, "pure"), body}, nil, t.first, t.final)
	fnname := "filt1"
	funargs := []Term{lhs, synthdpred}
	if xfm != nil {
		fnname = "filt1x"
		xbody := makeScopedTermL(Stmts, makeScope(), []Term{xfm}, nil, Pos(-1), Pos(-1))
		synthdxfm := makeTermL(FunLit, []Term{thissym, inxsym, nil, SynthToken(IDENT, "pure"), xbody}, nil, t.first, t.final)
		funargs = append(funargs, synthdxfm)
	}
	return makeFuncall(SynthToken(IDENT, fnname), funargs, nil, t)
}

// explore trm as needed to tell if it's asgnble
func isAsgnble(trm Term) bool {
	trmtg := trm.Tag()
	root := trm
	if trmtg == Symchain {
		root = trm.(*TermL).args[0]
	}
	if callingNamed(root, "rvalindex") {
		// I believe the only thing that returns an asgnble elt is rvalindex with rcvr "var"
		return isAsgnble(root.(*TermTL).args[0])
	}
	if root.Tag() == Gdref {
		root = root.(*TermT).arg0
	}
	if root.Tag() == SymbolTag {
		sym := root.(*Symbol)
		return sym.plist.Find("var") != nil || sym.plist.Find("rcvrLinked") != nil ||
			(trmtg == Symchain && sym.plist.Find("itervar") != nil)
	}
	return false
}

func eqHelper(tg Termtag) (flip bool, adjtag Termtag) {
	flip = tg == NeqExpr || tg == NeqeqExpr
	adjtag = tg
	if flip {
		if tg == NeqExpr {
			adjtag = EqExpr
		} else {
			adjtag = EqeqExpr
		}
	}
	return
}

// This is a bunch of operators plus dot, dotbrace, import, LBRACK indexing, oncond,
// ontime, while, tilde, extend.
func (t *TermTT) Typecheck(cntt *Type, tci *TCInfo) Term {
	tci.RecordBackup(t)
	switch t.kind {
	default:
		panic("impossible")
	case EqExpr, EqeqExpr, NeqExpr, NeqeqExpr:
		// check cntts, consider guarding, and create a Lognot prefix for the Neq tags.
		seen := []*Type{}
		if cntt != nil && !TypeBool.compat(cntt, &seen) {
			return tci.ErrorExpect(cntt, TypeBool, t)
		}
		negeq, adjtag := eqHelper(t.kind)
		if callingNamed(t.arg0, "tag") {
			return tci.maybeTagGuard(!negeq, t.arg0, t.arg1)
		}
		a0 := t.arg0.Typecheck(nil, tci)
		if a0.Tag() == ErrorTag {
			return a0
		}
		// We have a dilemma for the cntt of the 2nd arg. In cases of x = y where one is nilposs(T) and the
		// other is T, we want to create a guard post-check to say the nilposs one is actually a T. We could
		// pass nilposs(a0.Dtype()) but that seems clumsy. OTOH, passing nil fails to give needed guidance to
		// the case of "x = []". For now, the soln adopted is to special case the latter.
		a0t := a0.Dtype()
		var cntt0 *Type
		t1tg := t.arg1.Tag()
		if t1tg == Litform && len(t.arg1.(*TermTL).args) == 0 || a0t == TypeByte {
			cntt0 = a0t
		} else if t1tg == Labellit && a0t.family == TFInt { // X = :eltval check for ELT
			eltval := indexELT(a0t, t.arg1.(*TermB).value)
			if eltval >= 0 {
				var ret Term
				ret = makeTermTT(adjtag, a0, makeIntlit(eltval), TypeBool, t.first, t.final)
				if negeq {
					ret = makeTermT(Lognot, ret, TypeBool, t.first, t.final)
				}
				return ret
			} else if itemExists(a0t, "ELT") {
				return tci.Error("label doesn't belong to ELT", t)
			} else {
				return tci.Error("can't compare int and label", t)
			}
		}
		a1 := t.arg1.Typecheck(cntt0, tci)
		if a1.Tag() == ErrorTag {
			return a1
		}
		a1t := a1.Dtype()
		seen = []*Type{}
		if !(a0t.compat(a1t, &seen) || a1t.compat(a0t, &seen)) {
			acfn := tryAutocvt(a0t, a1t, tci)
			if acfn != nil {
				a0 = makeFuncall(acfn, []Term{a0}, acfn.dtype.v.(*Ftntype).rettype, nil)
			} else {
				acfn = tryAutocvt(a1t, a0t, tci)
				if acfn != nil {
					a1 = makeFuncall(acfn, []Term{a1}, acfn.dtype.v.(*Ftntype).rettype, nil)
				} else {
					return tci.Error("operands may not be compared", t)
				}
			}
		}
		tci.maybeGuard(!negeq, a0, a1)
		var ret Term
		eqtrm := a0t.methods.Find("==")
		if eqtrm != nil && a1t.methods.Find("==") == eqtrm {
			ret = makeFuncall(eqtrm, []Term{a0, a1}, TypeBool, a0t)
		} else {
			ret = makeTermTT(adjtag, a0, a1, TypeBool, t.first, t.final)
		}
		if negeq {
			ret = makeTermT(Lognot, ret, TypeBool, t.first, t.final)
		}
		return ret
	case DotdotExpr, Dot3Expr:
		a0 := t.arg0.Typecheck(TPNumber, tci)
		if a0.Tag() == ErrorTag {
			return a0
		}
		t.arg0 = a0
		atyp := a0.Dtype()
		a1 := t.arg1.Typecheck(atyp, tci)
		if a1.Tag() == ErrorTag {
			return a1
		}
		t.arg1 = a1
		// at this point, we've got both args in either int or float. Check for autocvt to list and return
		// a range litform optionally wrapped in an autocvt call.
		seen := []*Type{}
		rangenm := "rangeI"
		elttyp := TypeInt
		if atyp.family == TFFloat {
			rangenm = "rangeF"
			elttyp = TypeFloat
		}
		listtyp := makeListType(elttyp)
		rangesym := tci.scopes.lookupType(rangenm)
		t.dtype = rangesym.binding.(*Type)
		incl := TrueLiteral
		if t.kind == Dot3Expr {
			incl = FalseLiteral
		}
		rnglit := makeTermL(Litform0, []Term{a0, a1, makeIntlit(1), incl}, t.dtype, t.first, t.final)
		// Note: the "cntt == nil" clause means rangelits are always cvtd unless explicitly told not to
		if cntt == nil || !t.dtype.compat(cntt, &seen) {
			return makeTermT(Range, rnglit, listtyp, t.first, t.final)
		}
		return rnglit
	case PluseqExpr, MinuseqExpr, MuleqExpr, DiveqExpr:
		opstrg := opstringMap[ttag2tcode[t.kind]]
		if cntt != nil && cntt != TypeNothing {
			return tci.Error(fmt.Sprintf("type %s expected but %s operator returns nothing", cntt.String(), opstrg), t)
		}
		flinx := tci.cxt.Find(FunLit, 0, NoTerm)
		if flinx < 0 || (*tci.cxt)[flinx].plist.Find("imp") == nil {
			return tci.Error(fmt.Sprintf("%s is only allowed in imp or mod functions", opstrg), t)
		}
		// operator is legal here; rewrite and TC that
		opstrg = "+"
		if t.kind == MinuseqExpr {
			opstrg = "-"
		} else if t.kind == MuleqExpr {
			opstrg = "*"
		} else if t.kind == DiveqExpr {
			opstrg = "/"
		}
		rhs := makeFuncall(SynthToken(IDENT, opstrg), []Term{t.arg0, t.arg1}, nil, nil)
		rwn := makeTermTT(AsgnStmt, t.arg0, rhs, nil, t.first, t.final)
		return rwn.Typecheck(nil, tci)
	case AsgnStmt:
		if t.arg0.Tag() == IndexExpr {
			// here, do RW to lvalindex
			ixtrm := t.arg0.(*TermTT)
			lviterm := makeFuncall(SynthToken(IDENT, "lvalindex"), []Term{ixtrm.arg0, ixtrm.arg1, t.arg1}, nil, t)
			return lviterm.Typecheck(cntt, tci)
		}
		if cntt != nil && cntt != TypeNothing {
			return tci.ErrorExpectStmt("assignment", cntt, t)
		}
		// Todo: this is highly unsatisfactory. There's an issue with lval TC in the presence of guards. I am pretty
		// sure it can apply to symchains as well as symbols but we mustn't disable guarding when it's of things
		// in the lhs expr that aren't being assigned to.
		if t.arg0.Tag() == Ident {
			tci.inLval = true
		}
		a0 := t.arg0.Typecheck(nil, tci)
		tci.inLval = false
		if a0.Tag() == ErrorTag {
			return a0
		}
		if !isAsgnble(a0) && tci.cxt.lastTag() != SymbolPattern {
			return tci.Error("lval is not assignable", t)
		}
		a0t := a0.Dtype()
		// if the lhs is nilposs but a0 infers to its maintype, we need to allow a nilposs rhs
		// This is a bit tricky because symchain dtypes are overwritten whereas Symbol's are wrapped in Gdref.
		// The next bit of code handles both cases, so that a0t is nilposs if it should be.
		// Later, I need to handle Gdref for generics, which should not deref the type. The existing
		tg0 := a0.Tag()
		if tg0 == Gdref {
			a0t = a0.(*TermT).arg0.Dtype()
			if a0t.family == TFTypred {
				a0t = a0.Dtype() // restore, it was generic
			}
		} else if tg0 == Symchain {
			a0a := a0.(*TermL).args
			lastarg := a0a[len(a0a)-1]
			if lastarg.Dtype().isNilposs() {
				a0t = lastarg.Dtype()
			}
		}
		var a1 Term
		if a0t.isNilposs() {
			// check compat carefully
			a1 = t.arg1.Typecheck(nil, tci)
			if a1.Tag() != ErrorTag {
				seen := []*Type{}
				a1t := a1.Dtype()
				if !(a1t == TypeNil || a0t.mainType().compat(a1t, &seen)) {
					return tci.ErrorExpect(a0t, a1t, t)
				}
			}
		} else {
			a1 = t.arg1.Typecheck(a0t, tci)
		}
		if a1.Tag() == ErrorTag {
			return a1
		}
		tci.disableGuard(a0) // any guard for lhs is now invalid
		return makeTermTT(AsgnStmt, a0, a1, TypeNothing, t.first, t.final)
	case IndexExpr:
		a0 := t.arg0.Typecheck(nil, tci)
		if a0.Tag() == ErrorTag {
			return a0
		}
		// if a1 is => binop, rewrite to filt1x call
		if t.arg1.Tag() == Arrow {
			a1tt := t.arg1.(*TermTT)
			return synthFilt(a0, a1tt.arg0, a1tt.arg1, tci, t).Typecheck(cntt, tci)
		}
		// if a1 infers to boolean, rewrite to filt1 call, else to rvalindex call.
		// Also handle special case of lst[a..b] which rewrites to select.
		// There's an obscure way for a1 to fail by itself but succeed as a filt1 call. So if we
		// get an error and the filt1 interpn succeeds, we delete the error.
		tci.makeTentative()
		tg := t.arg1.Tag()
		a0t := a0.Dtype()
		if (a0t.family == TFList || a0t.family == TFString) && (tg == DotdotExpr || tg == Dot3Expr) {
			dotx := t.arg1.(*TermTT)
			upper := dotx.arg1
			if tg == DotdotExpr {
				upper = makeFuncall(&Token{IDENT, Pos(-1), "+"}, []Term{upper, makeIntlit(1)}, nil, nil)
			}
			selcall := makeFuncall(&Token{IDENT, Pos(-1), "select"}, []Term{a0, dotx.arg0, upper}, nil, nil)
			tci.unmakeTentative()
			return selcall.Typecheck(cntt, tci)
		}
		a1 := t.arg1.Typecheck(nil, tci)
		possErr := tci.unmakeTentative()
		if a1.Tag() == ErrorTag || a1.Dtype().Equal(TypeBool) {
			filt1interpn := synthFilt(a0, t.arg1, nil, tci, t).Typecheck(cntt, tci)
			if filt1interpn.Tag() == ErrorTag {
				if possErr != nil {
					return possErr
				}
			}
			return filt1interpn
		}
		rvi := makeFuncall(SynthToken(IDENT, "rvalindex"), []Term{a0, a1}, nil, t)
		return rvi.Typecheck(cntt, tci)
	case Dot: // this is not "foo.bar(a,b,...)" -- that's handled under Funcall
		seen := []*Type{}
		rhs := t.arg1.(*Token) // parser guarantees this
		if t.arg0.Tag() == Ident {
			a0tok := t.arg0.(*Token)
			qi := QIScope[a0tok.val]
			if qi != nil {
				sym, _ := qi.scope.Lookup(rhs.val)
				if sym != nil && (cntt == nil || sym.dtype.compat(cntt, &seen)) {
					return sym
				}
			}
		}
		// here, no QI;
		a0 := tci.tryGuardfixNP(t.arg0.Typecheck(nil, tci))
		if a0.Tag() == ErrorTag {
			return a0
		}
		a0t := a0.Dtype()
		atrb := a0t.attributeLookup(rhs.val)
		if tci.inXprftn {
			xprsym, _ := tci.scopes.Lookup(rhs.val)
			if xprsym != nil && xprsym.dtype == Gzsym && xprsym.binding != nil {
				atrb = xprsym.binding.(*Symbol)
			}
		}
		if atrb != nil {
			// accum into a Symchain else create a new one
			var scterm *TermL
			if a0.Tag() == Symchain {
				scterm = a0.(*TermL)
				scterm.args = append(scterm.args, atrb)
				scterm.dtype = atrb.dtype
			} else {
				scterm = makeSymchain([]Term{a0, atrb}, atrb.dtype, t.first, t.final)
			}
			tci.trySymchainfixNP(scterm)
			if cntt == nil || scterm.dtype.compat(cntt, &seen) {
				return scterm
			}
			if cntt != nil {
				acfn := tryAutocvt(scterm.dtype, cntt, tci)
				if acfn != nil {
					return makeFuncall(acfn, []Term{scterm}, acfn.dtype.v.(*Ftntype).rettype, nil)
				}
			}
		}
		// not attribute either. Try the ftn interpn
		asFtn := makeFuncall(rhs, []Term{a0}, nil, t)
		ret := asFtn.TCFuncall(cntt, tci)
		if ret.Tag() == ErrorTag {
			if len(tci.errors) == 1 {
				return tci.errors[0]
			} else {
				tci.ClearErrors()
				return tci.Error(fmt.Sprintf("cannot find interpretation of %s", t), t)
			}
		}
		ret = modcheck(ret, tci)
		return ret
	case Dotbrace:
		// RW to maplst
		a0 := t.arg0.Typecheck(TPEnumerable, tci) // a0 inferred type serves to get elttype
		if a0.Tag() == ErrorTag {
			return a0
		}
		eltyp := a0.Dtype().Elttype()
		if eltyp == nil {
			return tci.Error("left operand of maplst is not enumerable", t)
		}
		thissym := makeSymbol("this", eltyp, nil)
		inxsym := makeSymbol("index", TypeInt, nil)
		var body Term
		if t.arg1.Tag() == Stmts {
			body = t.arg1
		} else {
			body = makeScopedTermL(Stmts, makeScope(), []Term{t.arg1}, nil, Pos(-1), Pos(-1))
		}
		if len(body.(*TermL).args) == 0 {
			return tci.Error("dotbrace may not have empty body", t)
		}
		synthdfn := makeTermL(FunLit, []Term{thissym, inxsym, nil, SynthToken(IDENT, "pure"), body}, nil, t.first, t.final)
		synthdxfm := makeFuncall(SynthToken(IDENT, "maplst"), []Term{a0, synthdfn}, nil, t)
		return synthdxfm.TCFuncall(cntt, tci)
	case Dotbracket:
		// RW to filt or filtx; this is possibly mergeable with Dotbrace TC but enough diffs to justify separation
		// Don't bother to rewrite and check if there's a cntt that's unsatisfiable
		seen := []*Type{}
		if cntt != nil && !cntt.compat(TPEnumerable, &seen) {
			return tci.Error("dotbracket is always enumerable", t)
		}
		a0 := t.arg0.Typecheck(TPEnumerable, tci) // a0 inferred type serves to get elttype
		if a0.Tag() == ErrorTag {
			return a0
		}
		eltyp := a0.Dtype().Elttype()
		if eltyp == nil {
			// this is not right, I need a more general approach. It's coded to handle string->list(byte)
			if a0.Dtype() == TypeString {
				lbyte := makeListType(TypeByte)
				acfn := tryAutocvt(a0.Dtype(), lbyte, tci)
				a0 = makeFuncall(acfn, []Term{a0}, lbyte, nil)
				eltyp = TypeByte
			} else {
				return tci.Error("left operand of dotbracket is not enumerable", t)
			}
		}
		thissym := makeSymbol("this", eltyp, nil)
		inxsym := makeSymbol("index", TypeInt, nil)
		body := t.arg1
		var arrowRhs Term
		btg := body.Tag()
		if btg == Stmts {
			stmtargs := body.(*TermL).args
			lastarg := len(stmtargs) - 1
			if stmtargs[lastarg].Tag() == Arrow {
				arw := stmtargs[lastarg].(*TermTT)
				stmtargs[lastarg] = arw.arg0
				arrowRhs = arw.arg1
			}
		} else {
			if body.Tag() == Arrow {
				arrowRhs = body.(*TermTT).arg1
				body = body.(*TermTT).arg0
			}
			body = makeScopedTermL(Stmts, makeScope(), []Term{body}, nil, Pos(-1), Pos(-1))

		}
		if len(body.(*TermL).args) == 0 {
			return tci.Error("dotbracket may not have empty body", t)
		}
		filtfn := makeTermL(FunLit, []Term{thissym, inxsym, nil, SynthToken(IDENT, "pure"), body}, nil, t.first, t.final)
		var dotbrackfn Term
		if arrowRhs != nil {
			xfmbody := makeScopedTermL(Stmts, makeScope(), []Term{arrowRhs}, nil, Pos(-1), Pos(-1))
			xfmfn := makeTermL(FunLit, []Term{thissym, inxsym, nil, SynthToken(IDENT, "pure"), xfmbody}, nil, t.first, t.final)
			dotbrackfn = makeFuncall(SynthToken(IDENT, "filtx"), []Term{a0, filtfn, xfmfn}, nil, t)
		} else {
			dotbrackfn = makeFuncall(SynthToken(IDENT, "filt"), []Term{a0, filtfn}, nil, t)
			//fmt.Println("TC dotbracket:", dotbrackfn.String())
		}
		return dotbrackfn.Typecheck(cntt, tci)
	case Arrow:
		// Arrow and tilde operators are anticipated in the few cases they're allowed
		return tci.Error("=> is not allowed here", t) // (viz dotbracket, case expr, and filtx)
	case TildeExpr:
		if tci.allowTilde {
			if t.arg0.Tag() != Labellit {
				return tci.Error("expecting label before ~", t)
			}
			tmp := t.arg1.Typecheck(nil, tci)
			if tmp.Tag() == ErrorTag {
				return tmp
			}
			t.arg1 = tmp
			t.dtype = TypeNothing
			return t
		}
		return tci.Error("~ is not allowed here", t) // (viz litform and always)
	case ExtendExpr:
		return tci.Error("extend is not allowed here", t)
	case WhileStmt:
		if cntt != nil && cntt != TypeNothing {
			return tci.ErrorExpectStmt("while", cntt, t)
		}
		// rewrite to loop stmt first (else guarding screws up)
		a0 := t.arg0
		a1s := t.arg1.(*TermL) // must be stmts
		p0 := a0.First()
		pn := a0.Final()
		//brktrm := makeScopedTermL(Stmts, nil, []Term{makeTermT(BreakStmt, nil, nil, p0, pn)}, nil, p0, pn)
		brktrm := makeTermT(BreakStmt, nil, nil, p0, pn)
		a0s := makeTermL(IfStmt, []Term{makeTermT(Lognot, a0, nil, p0, pn), brktrm}, nil, p0, pn)
		// insert the ifstmt at front of while body
		loopbody := make([]Term, len(a1s.args)+1)
		copy(loopbody[1:], a1s.args)
		loopbody[0] = a0s
		loopstmt := makeTermT(LoopStmt, makeScopedTermL(Stmts, nil, loopbody, nil, a1s.first, a1s.final), nil, t.first, t.final)
		return loopstmt.Typecheck(TypeNothing, tci)
	case OncondStmt:
		if cntt != nil && cntt != TypeNothing {
			return tci.Error("oncondition cannot return "+cntt.String(), t)
		}
		// special case "oncondition exit ..."
		if t.arg0.Tag() == Ident && t.arg0.(*Token).val == "exit" {
			body := t.arg1.Typecheck(TypeNothing, tci)
			if body.Tag() == ErrorTag {
				return body
			}
			return makeTermT(Deferstmt, body, TypeNothing, t.first, t.final)
		}
		cond := t.arg0.Typecheck(TypeBool, tci)
		if cond.Tag() == ErrorTag {
			return cond
		}
		manif := Manifest(cond)
		if manif {
			// assume for now this means it uses "defined". That's slightly wrong.
			// DefConds holds deferred conditions, calling its addElement method either stores the new condition thereon
			// or tells us to run it now.
			if defConds.addElement(cond, t.arg1, tci.scopes) {
				for _, stmt := range t.arg1.(*TermL).args {
					rslt := stmt.Typecheck(nil, tci)
					if rslt.Tag() == ErrorTag {
						return rslt
					}
				}
			}
			return t
		} else if tci.scopes.topscope {
			return tci.Error("non-manifest oncondition may not occur in global context", t)
		}
		body := t.arg1.Typecheck(TypeNothing, tci)
		if body.Tag() == ErrorTag {
			return body
		}
		t.arg0 = cond
		t.arg1 = body
		t.dtype = TypeNothing
		return t
	case AtExpr:
		// rhs has to be a time
		a1 := t.arg1.Typecheck(TypeTime, tci)
		if a1.Tag() == ErrorTag {
			return a1
		}
		// if lhs is a litform, it has to be of situated type
		panic("unwritten")
	case ImportStmt, ImportPkgStmt:
		path := t.arg0.(*Token).val
		mname := t.arg1.(*Token).val
		if t.kind == ImportStmt {
			return tcImport(path, mname, tci, t)
		} else {
			return tcImportPkg(path, mname, tci, t)
		}
	}
	return Simplify(t)
}

// tcFunlitWithDefaulted does tcFunlit's job in the special case that the ftnlit
// has optional args. This can only happen with std ftns getting bound to a symbol.
// Formally, it's a quick & dirty way to define some multibound ftns all at once, and in fact,
// that's how it's treated internally. It's easy to see that if N is the number of optional args
// in a ftnlit, it generates 2**N Symbols, each an interpretation of the function.
// We return either an error term (a *TermB) or a []*Symbol. Given that these are quite different
// I decided to just do the TC dynamically on this one.
//
// The multibinding interpretation of optional args gives a nice, clean semantics but optional args
// introduce some complexities all the same. They make it really easy to define functions that can't
// be statically typechecked. (Or in fact, typechecked at all without using keywords to name args.)
// It turns out the condition for static typechecking is pretty simple. Consider the arguments as a
// vector of types. Each contiguous sub-sequence of optionals creates a "fluid" part of that vector,
// which also includes its "boundaries" (the non-optional arguments that can be on the left and right
// of the fluid part). A vector of types with optionality attributes is statically typecheckable
// just in case no fluid part contains two types that are the same (formally, are not TC-distinct).
// This calculation can be done while we're collecting the args. (There's a corner case when the arg
// list consists of a single optional argument. We also need to enforce the rule that a moddable
// receiver argument cannot be optional.)
func (t *TermL) tcFunlitWithDefaulted(ident string, tci *TCInfo) interface{} {
	nargs := len(t.args)
	purwd := t.args[nargs-2].(*Token).val
	impflag := purwd == "imp"
	modflag := purwd == "mod"
	tci.cxt.Push(FunLit)
	tci.cxt.SetItem("imp", impflag || modflag)
	ftnscope := makeScope()
	tci.PushScope(ftnscope)
	type xarg struct {
		ident   string
		typ     *Type
		dfltval Term // nil for non-optional args
	}
	funargs := make([]xarg, nargs-3)
	argtypes := make([]*Type, nargs-3)
	var optlcount uint
	fluidstart := 0 // this is an index
	inFluid := false
	for i, a := range t.args[0 : nargs-3] {
		symdecl := a.(*TermL)
		funargs[i].ident = symdecl.args[0].(*Token).val
		var typ *Type
		fmltype := symdecl.args[1]
		if fmltype != nil {
			typ0 := TC4Type(fmltype, nil, tci)
			if typ0.Tag() == ErrorTag {
				return typ0
			}
			typ = typ0.(*Type)
		}
		if len(symdecl.args) == 4 {
			// this one is defaulted
			optlcount += 1
			dval := symdecl.args[3].Typecheck(typ, tci)
			if dval.Tag() == ErrorTag {
				return dval
			}
			if typ == nil {
				typ = dval.Dtype()
			}
			funargs[i].dfltval = dval
		}
		funargs[i].typ = typ
		argtypes[i] = typ
		// this is obscure, but the parser allows dbl colon which is never legit in this kind of ftnlit.
		if symdecl.args[2].(*Token).val != "__single" {
			return tci.Error("'::' is not allowed in standard function literals", t)
		}
		if len(symdecl.args) == 4 && !inFluid {
			inFluid = true
			fluidstart = i - 1
			if fluidstart < 0 {
				fluidstart = 0
			}
		}
		if inFluid {
			for i0 := fluidstart; i0 < i; i0++ {
				if funargs[i0].typ.compat(typ, nil) {
					msg := fmt.Sprintf("formals %s and %s are incompatible with optionality", funargs[i0].ident, funargs[i].ident)
					return tci.Error(msg, t)
				}
			}
		}
	}
	var retcntt *Type
	if t.args[nargs-3] != nil {
		retcntt0 := TC4Type(t.args[nargs-3], nil, tci)
		if retcntt.Tag() == ErrorTag {
			return retcntt0
		}
		retcntt = retcntt0.(*Type)
	}
	// now TC the body, which is a stmtlist
	body := t.args[nargs-1].Typecheck(retcntt, tci)
	if body.Tag() == ErrorTag {
		return body
	}
	body0 := body.(*TermL)
	if retcntt == nil {
		retcntt = body0.dtype
	}
	// at this point, everything TC's. We're going to generate 2**optlcount Funinsts and Symbols
	// to return. A recursive function is convenient here.
	retSyms := make([]*Symbol, int(1<<optlcount))
	funargSyms := make([]*Symbol, len(funargs))
	for i, a := range funargs {
		funargSyms[i] = makeSymbol(a.ident, a.typ, nil)
	}
	if modflag {
		funargSyms[0].plist.Add("var", true)
	}
	// first, make the Funinst and Symbol for the function with no args left out
	fulltype := makeType(TFFtn, argtypes, retcntt, !modflag)
	fullFuni := makeFuninst(ftnscope, funargSyms, fulltype, body0)
	retSyms[0] = makeSymbol(ident, fulltype, fullFuni)
	actuals := make([]Term, len(funargs))
	// note: copy won't asgn a *Symbol to a Term, so unbundle this
	for i, s := range funargSyms {
		actuals[i] = s
	}
	var genOptls func(rslts []*Symbol, inx0 int, fmlargs []*Symbol, actlargs []Term) []*Symbol
	genOptls = func(rslts []*Symbol, inx0 int, fmlargs []*Symbol, actlargs []Term) []*Symbol {
		if inx0 == len(funargs) {
			return rslts
		} else if funargs[inx0].dfltval == nil {
			return genOptls(rslts, inx0+1, fmlargs, actlargs)
		}
		// synthesize a ftn without the optional arg, as a call to the full one.
		arglist0 := make([]*Symbol, len(fmlargs)-1)
		argtypes0 := make([]*Type, len(fmlargs)-1)
		copy(arglist0[0:inx0], fmlargs[0:inx0])
		copy(arglist0[inx0:], fmlargs[inx0+1:])
		actl0 := make([]Term, len(actlargs))
		copy(actl0, actlargs)
		actl0[inx0] = funargs[inx0].dfltval
		callFull := makeFuncall(retSyms[0], actl0, retcntt, t)
		lclScope := makeScope()
		for _, a := range arglist0 {
			lclScope.Add(a, 0)
		}
		funtype0 := makeType(TFFtn, argtypes0, retcntt, !modflag)
		body1 := makeScopedTermL(Stmts, makeScope(), []Term{callFull}, funtype0, t.first, t.final)
		nxFuni := makeFuninst(lclScope, arglist0, funtype0, body1)
		rslts = append(rslts, makeSymbol(ident, funtype0, nxFuni))
		return genOptls(rslts, inx0+1, arglist0, actl0)
	}
	return genOptls(retSyms, 0, funargSyms, actuals)
}

// Helper for both syntactic cxts that accept Symdecl term with either : or ::
// The rcvr must be a Symdecl; return a Symbol or an ErrorTag.
func (symdecl *TermL) singleDouble(tci *TCInfo) Term {
	ident := symdecl.args[0].(*Token).val
	fmltype := symdecl.args[1]
	var sym *Symbol
	if symdecl.args[2].(*Token).val == "__single" {
		fmlarg0 := TC4Type(fmltype, nil, tci)
		if fmlarg0.Tag() == ErrorTag {
			return fmlarg0
		}
		sym = makeSymbol(ident, fmlarg0.(*Type), nil)
	} else {
		// here, the part after :: has to be an identifier designating a typred
		tpredIdent := fmltype.(*Token).val
		bpredtpred := tci.scopes.lookupTypred(tpredIdent) // *Symbol or nil
		if bpredtpred == nil {
			return tci.Error(fmt.Sprintf("%s is not a typepred", tpredIdent), fmltype)
		}
		sym = makeSymbol(ident, nil, makeType(TFGTS, makeGTS(ident, bpredtpred.binding.(*Type))))
	}
	return sym
}

// tcTGenLit is a helper for tcFunlit; handles the typegen case.
func (t *TermL) tcTGenlit(cntt *Type, tci *TCInfo) Term {
	tci.cxt.Push(FunLit)
	defer tci.cxt.Pop()
	tci.cxt.SetItem("imp", false)
	ftnscope := makeScope()
	tci.PushScope(ftnscope)
	defer tci.PopScope()
	// first, check the args
	nargs := len(t.args)
	nFunargs := nargs - 3
	fmlargs := make([]*Symbol, nFunargs)
	for i, a := range t.args[0:nFunargs] {
		sym := a.(*TermL).singleDouble(tci)
		if sym.Tag() == ErrorTag {
			return sym
		}
		sym0 := sym.(*Symbol)
		fmlargs[i] = sym0
		ftnscope.Add(sym0, 0)
	}
	// there should be no return type, so go straight to body
	tci.cxt.SetItem("typegen", ftnscope) // check for nested gnc type defns needs this info
	bodystmts := t.args[nargs-1].(*TermL).args
	lastinx := len(bodystmts) - 1
	errmsg := "illegal statement in typegen"
	// first pass does a sanity check: initial stmts must be val, last must be something that evals to type
	for i, a := range bodystmts {
		tg := a.Tag()
		if i == lastinx {
			if !(tg == ExtendExpr || tg == Funcall || tg == Ident || tg == OrtypeLit || tg == TupleTypeLit) {
				return tci.Error(errmsg, t)
			}
		} else if tg != Valdecl {
			return tci.Error(errmsg, t)
		}
	}
	var xtnd Term
	for i, a := range bodystmts {
		if i < lastinx {
			xtnd = a.Typecheck(nil, tci)
			if xtnd.Tag() == ErrorTag {
				return xtnd
			}
		} else {
			xtnd = TC4Type(a, cntt, tci)
			if xtnd.Tag() == ErrorTag {
				return xtnd
			}
		}
	}
	// looks good; create a Typegen and return that.
	xtnd0 := xtnd.(*Type)
	tgen := makeTypegen(xtnd0, fmlargs)
	tgen.dtype.generator = tgen
	return tgen
}

// checkReturns is another helper for tcFunlit; reconciles all recorded return stmts.
// The returnItems arg is the return stmts recorded while traversing the funlit code.
// Produces an inferred rettype if there are any, else nil. Also can return an error if there are
// multiple incompatible return types. Finally,
func checkReturns(returnItems interface{}, inferred *Type, tci *TCInfo, t Term) Term {
	if returnItems == nil {
		return inferred
	}
	nilposs := false
	for _, ret0 := range returnItems.([]interface{}) {
		seen := []*Type{}
		ret := ret0.(Term)
		rtyp := ret.Dtype()
		if rtyp.family == TFNil {
			nilposs = true
		} else if inferred == TypeExit && rtyp != TypeExit {
			return rtyp
		} else if !rtyp.compat(inferred, &seen) {
			lci := tci.scanner.getLineCharInfo(rtyp.First().byteIndex(), "")
			return tci.Error(fmt.Sprint("incompatible types in return statement (", lci.linenum, ",", lci.colnum, ")"), t)
		}
		if inferred == nil {
			inferred = rtyp
		}
	}
	if nilposs {
		return makeNilposs(inferred)
	}
	return inferred
}

// Look for TEM in a single SymXDict which will be the local scope of an xprftn
var isTEM = func(sym *Symbol, syms SymXDict) bool {
	if sym.binding == nil {
		for i := 0; i < len(syms); i++ {
			if syms[i].sym == sym {
				return true
			}
		}
	}
	return false
}

// Note that this works on symbols pre-TC. TC clears the binding so post-TC a diff protocol applies to PEMs.
func isPEM(sym *Symbol) bool {
	return callingNamed(sym.binding, "matching")
}

// Since this uses isPEM, the restriction noted there applies here too: pre-TC symbols only.
func isMatchable(trm Term) bool {
	if trm.Tag() == SymbolTag {
		sym := trm.(*Symbol)
		return sym.binding == nil || isPEM(sym)
	}
	return false
}

// fixupXprftn is another helper for tcFunlit, it gets the body of the ftn as interned and modifies it
// in various ways. It smashes the arg's internals, IOW it's a mod ftn.
func fixupXprftn(body *TermL, syms SymXDict) (cp *Pattern) {
	argsx := make([]Term, 0, len(body.args))
	// Maybe some decls at src level define multiple symbols but internally, they've already changed to 1 per stmt
	for _, stmt := range body.args {
		tg := stmt.Tag()
		switch tg {
		case Valdecl, Vardecl:
			decld := stmt.(*TermT).arg0.(*Symbol)
			if !(isTEM(decld, syms) || isPEM(decld)) {
				argsx = append(argsx, stmt)
			}
			// IOW if it's a TEM or PEM, no need to declare it, it's in the scope
		case Funcall:
			if callingNamed(stmt, "matchquery") {
				cp = stmt.Plist().Find("CP").(*Pattern)
			} else {
				// if it's anything else, like skipIf, we need to keep it
				argsx = append(argsx, stmt)
			}
		default:
			// probably has to be Ifstmt...
			argsx = append(argsx, stmt)
		}
		body.args = argsx // smashola
	}
	return
}

// Workfn to figure out if trm contains an asgnmt to the term in stt
func asgnsWF(trm Term, stt interface{}) int {
	lhs := stt.(Term)
	switch trm0 := trm.(type) {
	case *Symbol: // assume no asgnmt stmt in local defn bindings, so don't pursue
		return 1
	case *TermTT:
		if trm0.kind == AsgnStmt && trm0.arg0.Equal(lhs) {
			return -1
		}
	}
	return 0
}

// tcFunlit for TermL handles Typecheck for the Funlit tag. This includes typegen, imp, etc.
// The incoming format: len(args) == len(ftnargs)+3. The last 3 elts are rettype (nil when
// omitted, which is common); purity word (dressed up as a token); body (always a Stmts Term).
//
// When things go well, we'll return a Funinst (or Typegen if indicated). Else ErrorTag TermB.
func (t *TermL) tcFunlit(cntt *Type, tci *TCInfo) Term {
	impflag := false
	modflag := false
	if !(cntt == nil || cntt.family == TFFtn || cntt == TPFunction) {
		return tci.Error(fmt.Sprintf("a function literal cannot match type %s", cntt.String()), t)
	}
	nargs := len(t.args)
	purityword := t.args[nargs-2].(*Token).val
	switch purityword {
	case "typegen":
		return t.tcTGenlit(cntt, tci)
	case "xprftn":
		tci.inXprftn = true
		tci.mqseen = false
		tci.rwstoreScope = makeScope()
		tci.PushScope(XprScope)
		defer func() { tci.PopScope(); tci.inXprftn = false }()
	case "imp":
		impflag = true
	case "mod":
		modflag = true
	}
	localFn := false
	if tci.cxt.Find(FunLit, 0, NoTerm) >= 0 {
		localFn = true
	}
	tci.cxt.Push(FunLit)
	defer tci.cxt.Pop()
	tci.cxt.SetItem("imp", impflag || modflag)
	// first, process the fmlargs. Parser ensures they're all Symdecls of [ident, type, colons] where colons
	// is __single or __double. For std ftns, colons should always be __single; parser does not check this.
	// set up local scope before processing the ftn body
	ftnscope := makeScope()
	ftnscope.plist.Add("funlitScope", true) // marker that tells when we exit a fnlit in the scope tree
	tci.PushScope(ftnscope)
	defer tci.PopScope()
	mdinx := tci.cxt.Find(MethodTag, 0, ExtendExpr)
	inMethod := mdinx > 0 && mdinx == len(*tci.cxt)-2
	nFunargs := nargs - 3
	argsOffset := 0
	if inMethod {
		nFunargs += 1
		argsOffset = 1
	}
	fmlargTypes := make([]*Type, nFunargs)
	fmlargs := make([]*Symbol, nFunargs)
	if inMethod {
		xxInx := tci.cxt.Find(ExtendExpr, 0, NoTerm)
		xtndType := (*tci.cxt)[xxInx].plist.Find("basetype")
		xtndType0 := xtndType.(*Type)
		self := makeSymbol("self", xtndType0, nil)
		ftnscope.AddIfPossible(self)
		fmlargs[0] = self
		fmlargTypes[0] = xtndType0
	}
	var cnttftyp *Ftntype
	if cntt != nil && cntt != TPFunction {
		cnttftyp = cntt.v.(*Ftntype)
	}
	for i, a := range t.args[0 : nFunargs-argsOffset] {
		// note: synthd funlits may have Symbol here instead of Symdecl term
		sym, isSym := a.(*Symbol)
		if isSym {
			seen := []*Type{}
			if cnttftyp != nil && !sym.dtype.compat(cnttftyp.fmlargs[i], &seen) {
				return tci.ErrorExpect(cnttftyp.fmlargs[i], sym.dtype, t)
			}
		} else if a.Tag() != Symdecl {
			return tci.Error("expected symbol declaration", a)
		} else {
			symdecl := a.(*TermL)
			if symdecl.args[2].(*Token).val != "__single" {
				return tci.Error("'::' may not be used here", a)
			}
			fmltype := symdecl.args[1]
			var typecntt *Type
			if cnttftyp != nil {
				typecntt = cnttftyp.fmlargs[i]
			}
			sym = makeSymbol(symdecl.args[0].(*Token).val, nil, nil)
			if fmltype.Tag() == Ident && typecntt == nil && tci.typeInDef != nil && fmltype.(*Token).val == tci.typeInDef.ident {
				sym.dtype = tci.typeInDef.binding.(*Type)
			} else {
				fmlarg0 := TC4Type(fmltype, typecntt, tci)
				if fmlarg0.Tag() == ErrorTag {
					return fmlarg0
				}
				sym.dtype = fmlarg0.(*Type)
				if typecntt != nil && typecntt.family == TFGTS {
					// this is quite klugey. I want to bind/check GTS but can't find a way to do it in TC4Type that doesn't
					// break stuff. All of this needs a scrubbing.
					gts := typecntt.v.(*GTS)
					if gts.binding == nil {
						gts.binding = sym.dtype
					} else {
						seen := []*Type{}
						if !sym.dtype.compat(gts.binding, &seen) {
							return tci.Error("type inconsistent with previous value", symdecl)
						}
					}
				}
			}
		}
		fmlargs[i+argsOffset] = sym
		fmlargTypes[i+argsOffset] = sym.dtype
		ftnscope.Add(sym, 0)
	}
	if modflag {
		if len(fmlargTypes) == 0 || !fmlargTypes[0].Moddable() {
			return tci.Error("mod function types must have moddable receiver type", t)
		}
		fmlargs[0].plist.Add("var", true)
	}
	var retcntt *Type // retcntt is return type, given or inferred
	var funtype *Type
	if t.args[nargs-3] != nil {
		// here, return type is explicit
		var xtlRettypeCntt *Type
		if cnttftyp != nil {
			xtlRettypeCntt = cnttftyp.rettype
		}
		retcntt0 := TC4Type(t.args[nargs-3], xtlRettypeCntt, tci)
		if retcntt0.Tag() == ErrorTag {
			return retcntt0
		}
		retcntt = retcntt0.(*Type)
		tci.cxt.SetItem("retcntt", retcntt)
		// if retcntt is a Typred create an expectedType symbol in ftnscope
		if retcntt.family == TFTypred {
			xtsym := makeSymbol("expectedType", nil, retcntt)
			ftnscope.Add(xtsym, 0)
		}
		// set things up for possible recursion
		funtype = makeType(TFFtn, fmlargTypes, retcntt, !modflag)
		tci.ftnInDef[len(tci.ftnInDef)-1].dtype = funtype
	} else if cnttftyp != nil {
		retcntt = cnttftyp.rettype
	}
	// now TC the body, which is a stmtlist
	rawbody := t.args[nargs-1]
	body := rawbody.Typecheck(retcntt, tci)
	if body.Tag() == ErrorTag {
		return body
	}
	body0 := body.(*TermL)
	// verify that body TC didn't bind any GTS used in the signature: collect all distinct generics and check them.
	// Note that this is a bandaid kind of checking, needs to be done at point of failure. This involves perhaps setting
	// the binding of GTS funargs before checking body or something like htat.
	for _, ty := range fmlargTypes {
		gncs0 := ty.generics()
		for _, gt := range gncs0 {
			gtv, isGTS := gt.v.(*GTS)
			if isGTS && gtv.binding != nil {
				errmsg := fmt.Sprintf("type %s is constrained by erroneous expression", gt.v.(*GTS).ident)
				return tci.Error(errmsg, t)
			}
		}
	}
	// grab list of return stmts, if any; use it to check and possibly flag problems.
	returnsItem := (*tci.cxt)[len(*tci.cxt)-1].plist.Find("returns")
	// set retcntt to body type unless (1) already set or (2) ftn ends with a loop stmt that contains return stmts
	var lastBodyStmt Term
	if len(body0.args) > 0 {
		lastBodyStmt = body0.args[len(body0.args)-1]
	}
	if returnsItem == nil || (lastBodyStmt != nil && lastBodyStmt.Tag() != LoopStmt) {
		if retcntt == nil || retcntt.family == TFGTS {
			retcntt = body0.dtype
		}
	}
	retcheck := checkReturns(returnsItem, retcntt, tci, t)
	if retcheck.Tag() == ErrorTag {
		return retcheck
	}
	// If lastBodyStmt is a loop without a return stmt, this is an error.
	if retcheck != TypeNothing && (lastBodyStmt != nil && lastBodyStmt.Tag() == LoopStmt) {
		hasReturnWF := func(trm Term, stt interface{}) int {
			switch trm0 := trm.(type) {
			case *Symbol: // assume no asgnmt stmt in local defn bindings, so don't pursue
				return 1
			case *TermTT:
				if trm0.kind == ReturnStmt {
					return -1
				}
			}
			return 0
		}
		if !TraversePre(lastBodyStmt, hasReturnWF, nil) {
			return tci.Error("missing return value", body)
		}
	}
	// Everything looks copasetic; let's put things together to make a Funinst.
	if funtype == nil {
		funtype = makeType(TFFtn, fmlargTypes, retcheck, !modflag)
	}
	funi := makeFuninst(ftnscope, fmlargs, funtype, body0)
	funi.isLocalfn = localFn
	if purityword == "xprftn" {
		if retcheck == TypeNothing {
			return tci.Error("xprftn must return something", t)
		}
		// this mods body0, removing matchable decls, compiling parses and patterns, etc.
		cp := fixupXprftn(body0, body0.scope.entries)
		funi.plist.Add("MQP", cp) // attached the compiled pattern for the matchquery
	} else if funtype.isMod() && TraversePre(funi.body, asgnsWF, funi.funargs[0]) {
		fmt.Println("setting asgnftn")
		funi.plist.Add("asgnftn", true)
	}
	if retcntt != nil && retcntt.family == TFTypred {
		xtsym := tci.scopes.lookupType("expectedType")
		if xtsym != nil && xtsym.plist.Find("used") != nil {
			funi.plist.Add("expectedType", xtsym)
		}
	}
	funi.markEnumonly()
	cnctdItem := (*tci.cxt)[len(*tci.cxt)-1].plist.Find("connected")
	if cnctdItem != nil {
		funi.plist.Add("connected", true)
	}
	if returnsItem != nil {
		// record returns (if any) in the funi
		funi.plist.Add("returns", returnsItem)
	}
	return funi
}

// tcTypred handles TypepredExpr tag and is called from tcDecl, since typepred expr is only
// legit in a decl. First arg to t is basepred, a Symdecl of form [ident, typred]
// then follow 0 or more affordance specs, each a pair [ident, type] tagged
// as either Symdecl or SymdeclAttrib. We're going to generate the Typred right here
// and put it into a Type (since Typred is not a Term). The basepred needs to be added
// to the scope tree since it may occur in the type exprs of the affordances. The ident
// comes from the decl and is placed in the generated Typred; this works because no multibinding
// for Typreds.
func (t *TermL) tcTypred(tci *TCInfo, ident string) Term {
	// parser ensures that t.args[0].Tag() == Symdecl; language design ensures that typepred
	// on rhs of :: is an identifier.
	bpredx := t.args[0].(*TermL)
	basepredIdent := bpredx.args[0].(*Token).val
	tpredIdent := bpredx.args[1].(*Token).val
	bpredtpred := tci.scopes.lookupTypred(tpredIdent)
	if bpredtpred == nil {
		return tci.Error(fmt.Sprintf("%s is not a typepred", tpredIdent), t)
	}
	bpredty := bpredtpred.binding.(*Type)
	famset := bpredty.v.(*Typred).familyset
	bpscope := makeScope()
	tci.PushScope(bpscope)
	defer tci.PopScope()
	bpred := makeSymbol(basepredIdent, nil, makeType(TFGTS, makeGTS(basepredIdent, bpredty)))
	bpscope.Add(bpred, 0)
	// now process the affordances
	naffdnc := len(t.args) - 1
	affbits := 0
	affdncs := make([]*Symbol, naffdnc)
	hasLT := -1
	hasLE := -1
	for i := 0; i < naffdnc; i++ {
		affxpr := t.args[i+1].(*TermL)
		if affxpr.kind == SymdeclAttrib {
			affbits |= (1 << uint(i))
		}
		typ := TC4Type(affxpr.args[1], nil, tci)
		if typ.Tag() == ErrorTag {
			return typ
		}
		affdncs[i] = makeSymbol(affxpr.args[0].(*Token).val, typ.(*Type), nil)
		if affdncs[i].ident == "<" {
			hasLT = i
		}
		if affdncs[i].ident == "<=" {
			hasLE = i
		}
	}
	if hasLT >= 0 && hasLE < 0 {
		// special treatment of "<" -- ensure "<=" is also defined
		affdncs = append(affdncs, makeSymbol("<=", affdncs[hasLT].dtype, nil))
	}
	typred := makeTypred(famset, bpscope, affdncs, affbits, ident)
	typredtype := makeType(TFTypred, typred)
	theGTS := bpred.binding.(*Type)
	theGTS.v.(*GTS).dtype = typredtype
	for _, sym := range affdncs {
		sym.plist.Add("givenscope", bpscope)
		sym.plist.Add("tpaffdnc", true)
	}
	return makeSymbol(ident, nil, typredtype)
}

// Typecheck for TermL handles stmts, map, stmap, each, if, export, extend,
// typepred, tuple, ortype, some decls: attrib, method.
// Returns a modified version of t or new structure.
func (t *TermL) Typecheck(cntt *Type, tci *TCInfo) Term {
	tci.RecordBackup(t)
	switch t.kind {
	default:
		if t.dtype == nil {
			panic("unexpected tag")
		}
	case Stmts:
		if len(t.args) == 0 {
			return makeScopedTermL(Stmts, makeScope(), []Term{}, TypeNothing, t.first, t.final)
		}
		// parser can create nested stmtlists via val+var decls. Flatten those first.
		// note that recursion is not possible here.
		extras := 0
		flatten := false
		for _, stmt := range t.args {
			if stmt.Tag() == Stmts {
				trm := stmt.(*TermL)
				extras += len(trm.args) - 1
				flatten = true
			}
		}
		stmtlist := t.args
		argsx := make([]Term, len(t.args)+extras) // put processed stmts back here
		if flatten {
			stmtlist = make([]Term, len(argsx))
			i := 0
			for _, stmt := range t.args {
				if stmt.Tag() == Stmts {
					trm := stmt.(*TermL)
					for _, s := range trm.args {
						stmtlist[i] = s
						i += 1
					}
				} else {
					stmtlist[i] = stmt
					i += 1
				}
			}
		}
		// if in pure ftnlit, check for var decls
		flinx := tci.cxt.Find(FunLit, 0, NoTerm)
		if flinx != -1 {
			// get the impflag property from the topmost FunLit cxt entry
			impflag := (*tci.cxt)[flinx].plist.Find("imp").(bool)
			if !(impflag || tci.inXprftn) {
				for _, s := range stmtlist {
					if s.Tag() == Vardecl {
						return tci.Error("var declarations not allowed in pure functions", s)
					}
				}
			}
		}

		// now we're ready to TC the statements
		tci.EnterGuardingCxt()
		defer tci.ExitGuardingCxt(Stmts)
		tci.PushScope(makeScope())
		lastinx := len(stmtlist) - 1
		cntt0 := TypeNothing
		inGiven := tci.cxt.lastTag() == GivenStmt
		for inx, stmt := range stmtlist {
			if inx == lastinx {
				cntt0 = cntt
			}
			argsx[inx] = stmt.Typecheck(cntt0, tci)
			// There's a bug here with the code design for tentative. Not clear what solution, possibly
			// a redesign of that aspect of TC. todo: resolve this
			if len(tci.errors) > 0 && tci.tentative == 0 {
				return tci.errors[len(tci.errors)-1]
			}
			// The following check is intended to warn/bail if a pure thing is done in the middle of a stmtlist
			// It mostly doesn't work (as of now) because we pass nothing as cntt and most of the TC code is happy to oblige.
			// Honestly, this is an area needing further thought.
			// Todo: carry out this work.
			if inx != lastinx && tci.cxt.lastTag() == FunLit {
				styp := argsx[inx].Dtype()
				tg := stmt.Tag()
				if styp != TypeNothing && tg != ImportStmt && tg != ImportPkgStmt && !anyModcall(argsx[inx]) {
					return tci.Error("unused value in statement list", stmt)
				}
			}
			if tci.exitHere && inx < lastinx {
				return tci.Error(argsx[inx].String()+" must be last in statement list", t)
			}
			// D8m says given bodies may only have certain kinds of decls, plus stmap, applyST, rewrite
			if inGiven {
				tg := argsx[inx].Tag()
				ok := tg == StmapStmt
				if tg == Funcall {
					// here for applyST and rewrite
					funtrm := argsx[inx].(*TermTL).trm
					if funtrm.Tag() == SymbolTag {
						funsym := funtrm.(*Symbol)
						ok = funsym.ident == "rewrite" || funsym.ident == "applyST"
					}
				} else if tg == Valdecl {
					// here to check it's the right kind of defn. The rules are a little complicated.
					// Allowed are ftns, xprftns, types, typreds, typegens. Ie ftns plus options coded with dtype==nil
					decl := argsx[inx].(*TermT).arg0.(*Symbol)
					ok = decl.dtype == nil || decl.dtype.family == TFFtn
				}
				if !ok {
					return tci.Error("this statement may not occur in given", t)
				}
			}
		}
		tci.exitHere = false
		// because of tentative, it's possible we're looking at an error so check for that
		if argsx[lastinx].Tag() == ErrorTag {
			return argsx[lastinx]
		}
		// set the inferred type; the GTS condition enables bound GTS's to return the concrete type
		if cntt == nil || cntt.family == TFGTS {
			seen := []*Type{}
			rettyp := argsx[lastinx].Dtype()
			if cntt != nil && cntt.v.(*GTS).binding != nil {
				cntt = cntt.v.(*GTS).binding
			}
			if !rettyp.compat(cntt, &seen) {
				return tci.ErrorExpect(cntt, rettyp, t)
			}
			cntt = rettyp
		}
		return makeScopedTermL(Stmts, tci.PopScope(), argsx, cntt, t.first, t.final)
	case IfStmt:
		tci.EnterGuardingCxt()
		defer tci.ExitGuardingCxt(IfStmt)
		gdicount := len(tci.gditems)
		tci.exitstmt = false // initialize
		cond := t.args[0].Typecheck(TypeBool, tci)
		if cond.Tag() == ErrorTag {
			return cond
		}
		// record disable status of local gditems in case tpart disables and epart needs restoral
		dstatus := make([]bool, len(tci.gditems))
		for i := 0; i < len(tci.gditems); i++ {
			dstatus[i] = tci.gditems[i].invalid
		}
		tpart := t.args[1].Typecheck(cntt, tci)
		if tpart.Tag() == ErrorTag {
			return tpart
		}
		ttype := tpart.Dtype()
		var epart Term
		if len(t.args) == 2 {
			if cntt != nil && cntt != TypeNothing {
				return tci.Error(fmt.Sprintf("if-then statement cannot have type %s", cntt.String()), t)
			}
			tci.exitHere = false // handle case where tpart wasn't in stmtlist
			smashDtype(tpart, TypeNothing)
			ttype = TypeNothing
		} else {
			tci.exitstmt = false // if thenpart set this, turn it off
			// flip the sense of any guards a/w this stmt
			for i, gdi := range tci.gditems[gdicount:] {
				tci.gditems[i+gdicount] = gdi.flip()
			}
			for i, _ := range tci.gditems {
				tci.gditems[i].invalid = dstatus[i]
			}
			epart = t.args[2].Typecheck(cntt, tci)
			if epart.Tag() == ErrorTag {
				return epart
			}
			// now combine the types from then and else parts, including nilposs if applicable
			etype := epart.Dtype()
			seen := []*Type{}
			if ttype == TypeNil && etype != TypeNil {
				ttype = makeNilposs(etype)
			} else if etype == TypeNil && ttype != TypeNil {
				ttype = makeNilposs(ttype)
			} else if etype.isNilposs() && ttype.Equal(etype.mainType()) {
				ttype = etype
			} else if ttype.isNilposs() && etype.Equal(ttype.mainType()) {
				etype = ttype
			} else if (ttype == TypeNothing || etype == TypeNothing) && ttype != etype && (cntt == nil || cntt == TypeNothing) {
				// I'm not quite sure the right approach here. Generally, we want to be able to smash if cntt is nil but not if the coder forgot to
				// put a case in an ITE chain. The following code goes after the specific case, it might be possible to generalize.
				if ttype == TypeNothing && tpart.Tag() == Stmts && len(tpart.(*TermL).args) == 0 {
					return tci.Error("missing code in if-then-else", tpart)
				}
				if etype == TypeNothing && epart.Tag() == Stmts && len(epart.(*TermL).args) == 0 {
					return tci.Error("missing code in if-then-else", epart)
				}
				ttype = TypeNothing
				etype = TypeNothing
				smashDtype(tpart, TypeNothing)
				smashDtype(epart, TypeNothing)
			} else if ttype == TypeExit {
				ttype = etype
			} else if ttype == TypeByte && etype == TypeInt {
				etype = ttype
			} else if !(ttype.compat(etype, &seen) || etype == TypeExit) {
				return tci.Error(fmt.Sprintf("incompatible then and else part: %s versus %s", ttype.String(), etype.String()), t)
			}
		}
		args := []Term{cond, tpart}
		if epart != nil {
			args = append(args, epart)
		}
		t = makeTermL(IfStmt, args, ttype, t.First(), t.Final())
	case AndandExpr, OrorExpr:
		// before we get here, the Lognot code (in TermT) has "demorganized" these operators, so
		// there won't be a ! in front of them.
		exprcount0 := len(tci.gditems)
		exprcount1 := 0 // will be gditem count after first clause, which we can keep
		for i, clause := range t.args {
			clausecount0 := len(tci.gditems)
			c0 := clause.Typecheck(TypeBool, tci)
			if c0.Tag() == ErrorTag {
				return c0
			}
			t.args[i] = c0
			if t.kind == OrorExpr {
				// flip the sense of any guards a/w the last clause
				for j, gdi := range tci.gditems[clausecount0:] {
					tci.gditems[j+clausecount0] = gdi.flip()
				}
			}
			if i == 0 {
				exprcount1 = len(tci.gditems)
			}
		}
		// all added gditems get care here: tag && items as such and delete || ones as they are no longer guaranteed
		for i, _ := range tci.gditems[exprcount0:] {
			if t.kind == AndandExpr {
				tci.gditems[i+exprcount0].notFlippable = true
			} else {
				tci.gditems[i+exprcount0] = tci.gditems[i+exprcount0].flip()
				tci.gditems[i+exprcount0].posDisable = true
				// don't disable guards arising from the first clause, they're still good
				// note: this conditional should maybe apply to the above adjustments as well?
				if i+exprcount0 > exprcount1 {
					tci.gditems[i+exprcount0].invalid = true
				}
			}
		}
		t.dtype = TypeBool
	case EachStmt:
		// this comes in with body in last arg, potentially as a multiple iterator each, which needs to be xfmd into nested stmts.
		// Extra args can be either extra iterators or index decls so extra hair is needed.
		// There are several steps. The final output form is normally 3 args, with the one coming in as HatExpr being
		// split into the first 2 args. If there's an index decl, put it as a 4th arg.
		// The pre-processing but denested form puts it in the same place but as the 3rd arg, since HatExpr isn't split yet.
		nargs := len(t.args)
		body := t.args[nargs-1]
		iterators := 0
		for _, arg := range t.args {
			if arg.Tag() == HatExpr {
				iterators++
			}
		}
		if iterators >= 2 {
			// unwrap nested
			var inxv Term
			for i := nargs - 2; i > 0; i -= 1 {
				if t.args[i].Tag() == HatExpr {
					nargs := []Term{t.args[i], body}
					if inxv != nil {
						nargs = append(nargs, inxv)
						inxv = nil
					}
					body = makeScopedTermL(EachStmt, nil, nargs, nil, t.first, t.final)
					body = makeScopedTermL(Stmts, nil, []Term{body}, nil, t.first, t.final)
				} else {
					inxv = t.args[i]
				}
			}
			t.args[1] = body
			if inxv == nil {
				t.args = t.args[:2]
			} else {
				t.args[2] = inxv
				t.args = t.args[:3]
			}
		} else if len(t.args) > 2 {
			// One iterator but also an index decl, so swap body and index decl
			t.args[1], t.args[2] = t.args[2], t.args[1]
			body = t.args[1]
		}
		eachscope := makeScope()
		t.scope = eachscope
		// create a scope and initz it with the itervar; then it's available for the body as well
		itervar, ok := t.args[0].(*TermTT) // the itervar should be a CARET expr
		if !ok {
			return tci.Error(fmt.Sprintf("expected ^ expression but found %s", t.args[0].String()), t)
		}
		itertkn, ok := itervar.arg0.(*Token)
		if !ok {
			return tci.Error(fmt.Sprintf("expected iteration variable but found %s", itervar.arg0.String()), t)
		}
		coll := itervar.arg1.Typecheck(TPEnumerable, tci)
		if coll.Tag() == ErrorTag {
			return tci.Error("entity iterated is not enumerable", t)
		}
		// rewrite reverse(x..y) and similar
		if callingNamed(coll, "reverse") && coll.(*TermTL).args[0].Tag() == Range {
			coll = coll.(*TermTL).args[0]
			rnglit := coll.(*TermT).arg0.(*TermL)
			incl := rnglit.args[3]
			if !Manifest(incl) {
				return tci.MissingFeature("can't handle non-manifest inclusive in range", t)
			}
			lo := rnglit.args[1] // note: swapped
			hi := rnglit.args[0] // note: swapped
			if incl == FalseLiteral {
				typ := lo.Dtype()
				var one Term
				one = makeIntlit(1)
				if typ != TypeInt {
					one = makeFloatTerm("1.0", Pos(-1))
				}
				hi = makeFuncall(typ.methods.Find("-"), []Term{lo, one}, typ, nil)
			}
			// swap lo,hi and negate incr
			incr, istb := rnglit.args[2].(*TermB)
			var incr0 Term
			if istb {
				if incr.Dtype() == TypeInt {
					value := incr.plist.Find("intval").(int)
					incr0 = makeIntlit(-value)
				} else {

				}
			} else {
				incr := rnglit.args[2]
				incr0 = makeTermT(Negate, incr, incr.Dtype(), incr.First(), incr.Final())
			}
			coll.(*TermT).arg0 = makeTermL(Litform0, []Term{lo, hi, incr0, TrueLiteral}, rnglit.dtype, rnglit.first, rnglit.final)
		} else if coll.Tag() == Litform0 && coll.Dtype().rangeType() {
			// here for each(x^[rangeI: ...], e.g. when the step size is nonstd
			eltyp := coll.(*TermL).args[0].Dtype()
			coll = makeTermT(Range, coll, makeListType(eltyp), coll.First(), coll.Final())
		}
		var itersym0 *Symbol
		if tci.inXprftn {
			// in xprftn, the itersym can be a matchable
			itersym0 = tci.scopes.LookupN(itertkn.val, 0)
		}
		if itersym0 == nil {
			itersym0 = makeSymbol(itertkn.val, coll.Dtype().Elttype(), nil)
			itersym0.plist.Add("itervar", true) // tag to get special treatment wrt attrib assign
		}
		eachscope.Add(itersym0, 0)
		if len(t.args) > 2 {
			inxv := t.args[2]
			if inxv.Tag() != Ident {
				return tci.Error("index var must be identifier", t)
			}
			inxsym := makeSymbol(inxv.(*Token).val, TypeInt, nil)
			eachscope.Add(inxsym, 0)
		}
		tci.cxt.Push(EachStmt)
		tci.PushScope(eachscope)
		body0 := body.Typecheck(TypeNothing, tci)
		if body0.Tag() == ErrorTag {
			return body0
		}
		tci.PopScope() // this is the eachscope
		tci.cxt.Pop()
		// at this point, everything checks out. Create and return a processed EachStmt.
		finalargs := []Term{itersym0, coll, body0}
		if len(t.args) > 2 {
			inxsym := eachscope.entries.Find(t.args[2].(*Token).val)
			finalargs = append(finalargs, inxsym)
		}
		return makeScopedTermL(EachStmt, eachscope, finalargs, TypeNothing, t.first, t.final)
	case ExportStmt:
		// t.args is a list of possibly type-qualified names of the symbols to export
		// we're going to store this in the import cxt so we can run it at the end, that way it
		// can appear anywhere in the file, incl before the exported symbols are defined.
		// Note that if there isn't an import cxt, we'll ignore this -- the file is being loaded
		// rather than imported. This can be desirable sometimes.
		importinx := tci.cxt.Find(ImportStmt, 0, NoTerm)
		if importinx >= 0 {
			tci.cxt.SetItemAt(importinx, "export", t)
		}
		t.dtype = TypeNothing
	case Attribdecl, AttribdeclPvt:
		// caller vfyd these are in extend; mod the type a/w "self"
		// but caller didn't check if basetype is tuple
		self, _ := tci.scopes.Lookup("self")
		if self.dtype.family != TFTuple {
			return tci.Error("attribute statement is only allowed when extending a tuple type", t)
		}
		bttup := self.dtype.v.(*Tupletype)
		// ok, we've got a list (usually length 1 but can be longer) of attrib decls, each a Symdecl
		for _, sdecl := range t.args {
			bpt, err := sdecl.(*TermL).TCAttrib(t.kind == AttribdeclPvt, tci)
			if err != nil {
				return err
			}
			for _, a := range bttup.attribs {
				if bpt.ident == a.ident {
					return tci.Error(bpt.ident+": already assigned", t)
				}
			}
			bttup.attribs = append(bttup.attribs, bpt)
		}
	case Methoddecl, MethoddeclPvt:
		// Caller vfyd these are in extend but not that rhs of = is a ftnlit
		// Also, the stx allows multiple comma-separated defns per "method" token
		// This is stylistically bad but legal. So formally, args is a list of Symdecl,
		// and each Symdecl has [ident, type, binding] triples. In practice, we'll usually
		// see a single Symdecl with ident and binding set.
		//
		// Note: the spec has optional function args; but they're not yet supported for method decls.
		tci.cxt.Push(MethodTag)
		selfsym, _ := tci.scopes.Lookup("self")
		basetype := selfsym.dtype
		for _, mdecl := range t.args {
			mthddecl := mdecl.(*TermL)
			ident := mthddecl.args[0].(*Token).val
			cntt0 := mthddecl.args[1]
			var ftype *Type
			if cntt0 != nil {
				cntt0 = TC4Type(cntt0, TPFunction, tci)
				if cntt0.Tag() == ErrorTag {
					return cntt0
				}
				ftype = cntt0.(*Type)
			}
			ftnlit := mthddecl.args[2]
			if ftnlit == nil {
				panic("implement unbound method option")
			}
			if ftnlit.Tag() != FunLit {
				return tci.Error("method definition must be of a function", ftnlit)
			}
			recursionOk := false
			ftnlit0 := ftnlit.(*TermL)
			// check for unsupported feature (compile crashes otherwise)
			for _, funarg := range ftnlit0.args {
				if funarg != nil && funarg.Tag() == Symdecl {
					if len(funarg.(*TermL).args) == 4 {
						return tci.Error("optional arguments aren't yet supported in method declarations", funarg)
					}
				} else {
					break
				}
			}
			nargs := len(ftnlit0.args)
			if ftnlit0.args[nargs-3] != nil {
				recursionOk = true
				sym := makeSymbol(ident, nil, nil)
				tci.ftnInDef = append(tci.ftnInDef, sym)
			}
			funi := ftnlit.Typecheck(ftype, tci)
			if funi.Tag() == ErrorTag {
				return funi
			}
			// If possibly recursing, we've already created the Symbol (and if actually recursing, we definitely
			// want to use this one, not another).
			var mthdsym *Symbol
			if recursionOk {
				mthdsym = tci.ftnInDef[len(tci.ftnInDef)-1]
				tci.ftnInDef = tci.ftnInDef[0 : len(tci.ftnInDef)-1]
				if mthdsym.plist.Find("recursive") != nil {
					funi.Plist().Add("recursive", true)
				}
			}
			if mthdsym == nil {
				mthdsym = makeSymbol(ident, funi.(*Funinst).dtype, funi)
			} else {
				mthdsym.binding = funi
			}
			// lithook has special conditions
			if ident == "lithook" {
				funi0 := funi.(*Funinst)
				funitype := funi0.dtype.v.(*Ftntype)
				funiself := funi0.funargs[0]
				if funitype.rettype == TypeNothing {
					// no explicit return: add a return self, and smash any explicit returns
					// Note that this depends on the fact that values recorded in "returns" plist item
					// have actual terms in the funi, ie we'll be modding the funi's body
					explicitReturns := funi.Plist().Find("returns")
					if explicitReturns != nil {
						for _, t := range explicitReturns.([]interface{}) {
							t0 := t.(*TermT)
							t0.arg0 = funiself
							t0.dtype = funiself.dtype
						}
					}
					funi0.body.args = append(funi0.body.args, funiself)
					funi0.body.dtype = funiself.dtype
					funitype.rettype = funiself.dtype
					funi0.dtype.SetString()
				} else if !funitype.rettype.Equal(funiself.dtype) {
					return tci.Error("lithook methods must return self", t)
				}
			}
			if basetype.canAddMethod(mthdsym) {
				basetype.addMethod(mthdsym)
			} else {
				return tci.Error(fmt.Sprintf("method %s already exists", mthdsym.ident), t)
			}
		}
		tci.cxt.Pop()
		return t
	case FunLit:
		return t.tcFunlit(cntt, tci)
	case TypepredExpr: // all legit uses of this are captured in tcDecl
		return tci.Error("typepred expression may not occur here", t)
	case MapExpr:
		// last arg is body, previous args are iterators and/or index exprs. TC in order, inject symbols
		// into active scope, then TC the body. From that, you get a rettype, which is the elttype
		// of the list you're going to decl for result. That body, with appropriate additions and edits,
		// becomes the body of innermost of nested each stmts derived from the iterators.
		// The whole thing gets wrapped in an anon ftn which is called. This bypasses the usual maplst
		// call (used for dotbrace), effectively inlining that call "by hand". Since we need various types
		// that are inferred along the way, we synth a post-TC Term, so the anon ftn is a Funinst, etc.
		// As a specific example, given map(i^L1, j^L2) { bodystmts; retexpr }
		// (where bodystmts is normally empty, L1 and L2 rep exprs) we synthesize
		// \(){ var rslt:list(T); var index = 0; each(i^L1) each(j^L2) { bodystmts; pushb(rslt, retexpr); index += 1 }; rslt }()
		// We take care that the actual identifier for "rslt" doesn't conflict with bodystmt or retexpr.
		fnbodyscope := makeScope()
		tci.PushScope(fnbodyscope)
		iterargCnt := len(t.args) - 1
		bodyterm := t.args[iterargCnt]
		iterators := make([]Term, 0, iterargCnt)
		for i := 0; i < iterargCnt; i++ {
			iter := t.args[i]
			iterscope := makeScope()
			// parser doesn't ensure args are of form x^y, so detect that error here
			if iter.Tag() != HatExpr {
				return tci.Error("iterator expected", t)
			}
			iter0 := iter.(*TermTT)
			itertkn := iter0.arg0
			if itertkn.Tag() != Ident {
				return tci.Error("iterator must be an identifier", t)
			}
			iterated := iter0.arg1.Typecheck(TPEnumerable, tci)
			if iterated.Tag() == ErrorTag {
				return iterated
			}
			itersym := makeSymbol(itertkn.(*Token).val, iterated.Dtype().Elttype(), nil)
			tci.PushScope(iterscope)
			iterscope.Add(itersym, 0)
			// the body slot is left nil for now, will be filled in later
			eachargs := []Term{itersym, iterated, nil}
			if i < iterargCnt-1 && t.args[i+1].Tag() == Ident {
				i += 1
				inxsym := makeSymbol(t.args[i].(*Token).val, TypeInt, makeIntlit(0))
				inxsym.plist.Add("var", true)
				iterscope.Add(inxsym, 0)
				eachargs = append(eachargs, inxsym)
			}
			iterators = append(iterators, makeScopedTermL(EachStmt, iterscope, eachargs, TypeNothing, t.first, t.final))
		}
		body := bodyterm.Typecheck(nil, tci)
		if body.Tag() == ErrorTag {
			return body
		}
		body0 := body.(*TermL) // Stmts
		// edits: decl rslt:list(rettyp) = [] and index=0, synth each stmts changing ret expr to pushb, and index incr
		rettyp := body0.dtype
		if rettyp == TypeNothing {
			return tci.Error("map expression must return a value", t)
		}
		body0.dtype = TypeNothing
		ftnbody := make([]Term, 3)
		nested := []*Scope{}
		findNested(body0, &nested)
		ident := identifierOutOfScope(tci.scopes, nested, "rslt", nil)
		listt := makeListType(rettyp)
		emptylist := makeTermL(Litform0, []Term{}, listt, Pos(-1), Pos(-1))
		rsltsym := makeSymbol(ident, listt, emptylist)
		rsltsym.plist.Add("var", true)
		fnbodyscope.Add(rsltsym, 0)
		ftnbody[0] = makeTermT(Vardecl, rsltsym, TypeNothing, Pos(-1), Pos(-1))
		lastinx := len(body0.args) - 1
		retexpr := body0.args[lastinx]
		pushb := listt.methodLookup("pushb")
		pushbx := makeFuncall(pushb, []Term{rsltsym, retexpr}, TypeNothing, nil)
		body0.args[lastinx] = pushbx
		// now walk backwards to nest the each stmts
		lastinx = len(iterators) - 1
		iterscope := tci.PopScope()
		for ; lastinx > 0; lastinx-- {
			iter0 := iterators[lastinx]
			iter0.(*TermL).args[2] = body
			iterbodyscope := makeScope() // stmtlist gets empty scope
			iterbodyscope.parent = iterscope.parent
			iterscope.parent = iterbodyscope
			body = makeScopedTermL(Stmts, iterbodyscope, []Term{iter0}, TypeNothing, Pos(-1), Pos(-1))
			iterscope = tci.PopScope()
		}
		tci.PopScope() // this pops fnbodyscope
		iterators[0].(*TermL).args[2] = body
		ftnbody[1] = iterators[0]
		ftnbody[2] = rsltsym
		stmts := makeScopedTermL(Stmts, fnbodyscope, ftnbody, listt, Pos(-1), Pos(-1))
		funtype := makeType(TFFtn, []*Type{}, listt, true)
		funiscope := makeScope()
		funiscope.parent = tci.scopes
		fnbodyscope.parent = funiscope
		funi := makeFuninst(funiscope, []*Symbol{}, funtype, stmts)
		return makeFuncall(funi, []Term{}, listt, t)
	case StmapStmt:
		if !(cntt == nil || cntt == TypeNothing) {
			return tci.Error(fmt.Sprintf("STMap statement does not return %s", cntt.String()), t)
		}
		return t.tcStmap(tci)
	case Ifcase:
		argsx := make([]Term, len(t.args))
		var inftyp *Type
		for inx, clz := range t.args {
			if clz.Tag() != Arrow {
				return tci.Error("expected => here", clz)
			}
			clz0 := clz.(*TermTT)
			var cond Term
			if tokenNamed(clz0.arg0, "else") {
				cond = TrueLiteral
			} else {
				cond = clz0.arg0.Typecheck(TypeBool, tci)
			}
			if cond.Tag() == ErrorTag {
				return cond
			}
			rhs := clz0.arg1.Typecheck(nil, tci)
			if rhs.Tag() == ErrorTag {
				return rhs
			}
			rtyp := rhs.Dtype()
			if inftyp == nil {
				inftyp = rtyp
			}
			if rtyp == TypeNothing {
				inftyp = TypeNothing
			} else if rtyp != TypeExit {
				seen := []*Type{}
				if inftyp != TypeNothing && !rtyp.compat(inftyp, &seen) {
					return tci.Error(fmt.Sprintf("clause type (%s) is incompatible with others", rtyp.String()), clz)
				}
			}
			if inftyp == TypeNothing && rtyp != TypeNothing {
				smashDtype(rhs, TypeNothing)
			}
			// ensure that each clause is "wrapped" in stmtlist; this prevents inlining from later moving code out of clauses
			if rhs.Tag() != Stmts {
				scp := makeScope()
				// probably no scope links to fix but in a couple of obscure cases...
				if rhs.Tag() == EachStmt {
					rhs0 := rhs.(*TermL)
					scp.parent = rhs0.scope.parent
					rhs0.scope.parent = scp
				} else if rhs.Tag() == LoopStmt {
					rhs0 := rhs.(*TermT).arg0.(*TermL)
					scp.parent = rhs0.scope.parent
					rhs0.scope.parent = scp
				}
				rhs = makeScopedTermL(Stmts, scp, []Term{rhs}, inftyp, rhs.First(), rhs.Final())
			}
			argsx[inx] = makeTermTT(Arrow, cond, rhs, inftyp, clz.First(), clz.Final())
		}
		t = makeTermL(Ifcase, argsx, inftyp, t.first, t.final)
	}
	return Simplify(t)
}

// Helper for TCFuncall, given a ftn symbol tagged with "varany".
// Arg va is a list of the specific types; after that any number of args of unconstrained type.
// On success, return a funcall, else error.
func tcVarargsFn(fn Term, trm *TermTL, tci *TCInfo) Term {
	args := trm.args
	va := fn.Dtype().v.(*Ftntype).fmlargs
	cooked := make([]Term, len(args))
	i := 0
	for ; i < len(args); i++ {
		var cntt *Type
		if len(va) > i {
			cntt = va[i]
		}
		tmp := args[i].Typecheck(cntt, tci)
		if tmp.Tag() == ErrorTag {
			return tmp
		}
		cooked[i] = tmp
	}
	return makeFuncall(fn, cooked, fn.Dtype().v.(*Ftntype).rettype, trm)
}

// Check Litform0 and Funcall terms for the use of concrete types where the decln involves a Typred. I am currently doing
// a "restricted to most common uses" implementation of this feature, beause I judge that to be quite a bit easier to code
// than a fully correct one. Specifically, we handle Typreds directly in tuple types and lithook functions. We allow at most one
// Typred in each function arglist or tuple attribute list. (Else panic.)
// At the moment this works only for tuple types that aren't embedded in other tuple types, because there is (so far) nothing
// to propagate the fact that a type (containing a typred attribute) has been changed. That needs to happen to make this
// work mroe completely.
// Return either the given arg, possibly modded with the conctype replacing the Typred. This implies that the trm provided
// must be smashable.
func subst4TypredLitform(trm *TermL) (retval Term) {
	retval = trm
	typ := trm.dtype
	if typ.family != TFTuple {
		return
	}
	tpInx := typ.plist.Find("typredIndex")
	tpCache0 := typ.plist.Find("typredXltns")
	if tpInx == nil {
		tpi0 := -1
		for i, a := range typ.v.(*Tupletype).attribs {
			if a.dtype.family == TFTypred {
				if tpi0 >= 0 {
					panic("cannot handle multiple typepreds in a litform")
				}
				tpi0 = i
			}
		}
		if tpi0 >= 0 {
			tpInx = tpi0
			typ.plist.Add("typredIndex", tpInx)
			tpCache0 = make([][]Term, 0, 2)
		}
	}
	if tpInx != nil {
		gncsym := typ.v.(*Tupletype).attribs[tpInx.(int)]
		conctype := trm.args[tpInx.(int)].Dtype()
		// look for cached type else create and cache one
		found := false
		for _, ce := range tpCache0.([][]Term) {
			if ce[0].Equal(conctype) {
				found = true
				trm.dtype = ce[1].(*Type)
				break
			}
		}
		if !found {
			// here, create a new type & add it to the cache. The gsym0 gets conczInfo.handleType to do what we want.
			gsym0 := makeSymbol("__", nil, gncsym.dtype)
			czi := makeConczInfo([]*Symbol{gsym0}, []Term{conctype})
			typ0 := czi.handleType(typ)
			trm.dtype = typ0
			tta := typ0.v.(*Tupletype).attribs
			astrgs := make([]string, len(tta))
			for i, a := range tta {
				astrgs[i] = fmt.Sprintf("%s:%s", a.ident, a.dtype.String())
			}
			//fmt.Println("litform: term is now", trm.String(), "type=", astrgs)
			// now fix up the cache and we're done
			typ.plist.Add("typredXltns", append(tpCache0.([][]Term), []Term{conctype, typ0}))
		}
	}
	return
}

// same idea as subst4TypredLitform, only for lithooks. Change the argtype and rettype of the ftn.
func subst4TypredLithook(trm *TermTL) (retval *TermTL) {
	retval = trm
	fnsym := trm.trm.(*Symbol)
	ftyp := fnsym.dtype.v.(*Ftntype)
	rettyp := ftyp.rettype // this will be the possibly generic type
	tpInx := rettyp.plist.Find("typredIndex")
	tpCache0 := rettyp.plist.Find("typredXltns")
	if tpInx == nil {
		tpi0 := -1
		for i, a := range rettyp.v.(*Tupletype).attribs {
			if a.dtype.family == TFTypred {
				if tpi0 >= 0 {
					panic("cannot handle multiple typepreds in a litform")
				}
				tpi0 = i
			}
		}
		if tpi0 >= 0 {
			tpInx = tpi0
			fnsym.plist.Add("typredIndex", tpInx)
			tpCache0 = make([][]Term, 0, 2)
		}
	}
	if tpInx != nil {
		gncsym := rettyp.v.(*Tupletype).attribs[tpInx.(int)]
		// we need to figure out if & how a concrete type is passed into the lithook and bound to the gnc; analyze the funi body
		funargInx := -1
		lhfuni := fnsym.binding.(*Funinst)
		for _, s := range lhfuni.body.args {
			if s.Tag() == AsgnStmt {
				lhs := s.(*TermTT).arg0
				if lhs.Tag() == Symchain && lhs.(*TermL).args[1] == gncsym {
					rhs := s.(*TermTT).arg1
					if rhs.Tag() == SymbolTag {
						for i, a := range lhfuni.funargs {
							if a == rhs.(*Symbol) {
								funargInx = i
								break
							}
						}
					}
				}
			}
		}
		if funargInx < 0 {
			return
		}
		concarg := trm.args[funargInx]
		conctype := concarg.Dtype()
		// next, std cache lookup
		found := false
		for _, ce := range tpCache0.([][]Term) {
			if ce[0].Equal(conctype) {
				found = true
				trm.trm = ce[1]
				break
			}
		}
		if !found {
			// here, create a new type & add it to the cache. The gsym0 gets conczInfo.handleType to do what we want.
			gsym0 := makeSymbol("__", nil, gncsym.dtype)
			czi := makeConczInfo([]*Symbol{gsym0}, []Term{conctype})
			typ0 := czi.handleType(rettyp)
			// that creates a concretized lithook function, which we subst for the generic one in the funcall
			// bug alert: assume only one lithook function
			lhfn0 := typ0.methodLookup("lithook")
			trm.trm = lhfn0
			trm.dtype = lhfn0.dtype.v.(*Ftntype).rettype
			// now fix up the cache and we're done
			fnsym.plist.Add("typredXltns", append(tpCache0.([][]Term), []Term{conctype, typ0}))
		}
	}
	return
}

// TCFuncall is called only if t.kind == Funcall. We need to handle various special
// cases first -- specially TC'd functions like always, the rewrite from x.y(z) to
// y(x, z), etc. Then for the std case of symb(arg0, ..., argK) we TC the args with
// no cntts with one exception. That is that we handle at most one case of "[]" as an
// arg value. Normally, this errors if TC'd with no cntt. Most times, the cntts of
// a matching ftn will fix this. Therefore we check for this, and TC after the other
// args have matched so we can pass in the cntt given by the corresponding fmlarg type.
func (t *TermTL) TCFuncall(cntt *Type, tci *TCInfo) (retval Term) {
	// first, a helper function for guarded list methods
	var guardedListMethod = func(nm string) bool {
		return nm == "head" || nm == "last" || nm == "popb" || nm == "popf" || nm == "tail"
	}
	// another helper ftn for special "enumonly" handling of chainops
	var isChainop = func(nm string) bool {
		return nm == "maplst" || nm == "filt" || nm == "filt1" || nm == "filtx" || nm == "filt1x"
	}
	defer func() {
		if retval == nil {
			fmt.Println("null retval on", t.String())
		} else if retval.Tag() == Funcall {
			fn := retval.(*TermTL).trm
			if itemExists(fn, "connected") {
				inx := tci.cxt.Find(FunLit, 0, NoTerm)
				if inx >= 0 {
					tci.cxt.SetItemAt(inx, "connected", true)
				}
			}
		}
	}()

	// main code follows
	nconsidered := len(tci.considered)
	defer func() {
		tci.considered = tci.considered[:nconsidered]
	}()
	if t.dtype != nil { // got a previously TC'd Term; just check against cntt
		if cntt != nil {
			seen := []*Type{}
			if !t.dtype.compat(cntt, &seen) {
				t0 := tryAutocvt(t.dtype, cntt, tci)
				if t0 != nil {
					return makeFuncall(t0, []Term{t}, t0.dtype.v.(*Ftntype).rettype, nil)
				} else {
					return tci.ErrorExpect(cntt, t.dtype, t)
				}
			}
		}
		return t
	}
	ftntag := t.trm.Tag()
	if ftntag == Ident {
		ftnname := t.trm.(*Token).val
		specftnArgs := specialFtnMap[ftnname]
		// specialFtnMap is pseudo-ftns like always, cast, cvt, etc.
		if specftnArgs != 0 {
			tmp := t.specialFuncall(ftnname, specftnArgs, cntt, tci)
			if tmp != nil {
				return tmp
			}
		}
		// Need to handle certain xprftns up front because they get type args and similar oddities.
		if tci.inXprftn {
			fnsym := XprScope.entries.Find(ftnname)
			if fnsym != nil {
				if len(fnsym.dtype.v.(*Ftntype).fmlargs) != len(t.args) {
					return tci.Error(fnsym.ident+" has wrong number of arguments", t)
				}
				argsx := make([]Term, len(t.args))
				fntyp := fnsym.dtype.v.(*Ftntype)
				for i, a := range t.args {
					argsx[i] = a.Typecheck(fntyp.fmlargs[i], tci)
					if argsx[i].Tag() == ErrorTag {
						return argsx[i]
					}
				}
				seen := []*Type{}
				if cntt != nil && !fntyp.rettype.compat(cntt, &seen) {
					return tci.ErrorExpect(cntt, fntyp.rettype, t)
				}
				return makeFuncall(fnsym, argsx, fntyp.rettype, t)
			}
		}
	}
	// Many tags are possible for t.trm -- Ident will be the most common by far, but Dot also, and
	// less commonly FunLit, Symbol (for synthd calls), Index, Funcall, Ifstmt, etc.
	// The computed ones usually corresp to non-manifest ftns whereas Ident, Symbol, and FunLit are manifest.
	if ftntag != Ident && ftntag != Dot {
		ftnexpr := t.trm.Typecheck(TPFunction, tci)
		ftntag0 := ftnexpr.Tag()
		if ftntag0 != ErrorTag {
			// we found a function, so see if it matches
			argsx := make([]Term, len(t.args))
			fntyp0 := ftnexpr.Dtype()
			if fntyp0.MatchFun(t.args, argsx, cntt, tci) {
				t.trm = ftnexpr
				t.args = argsx
				t.dtype = fntyp0.v.(*Ftntype).rettype
				return t
			}
		}
		return ftnexpr
	}
	// At this point, it could be a multibound symbol, a method call in either std or dot form, or a dot form ftn call
	// We try dot form if ftntag is Dot and method lookup if the #args is >0. That covers everything.
	if ftntag == Dot {
		dotrm := t.trm.(*TermTT)
		if dotrm.arg0.Tag() == Ident {
			a0tok := dotrm.arg0.(*Token)
			qi := QIScope[a0tok.val]
			if qi != nil {
				fnname := dotrm.arg1.(*Token).val
				sym, upc := qi.scope.Lookup(fnname)
				if sym != nil && sym.dtype != nil && sym.dtype.family == TFFtn {
					// here we have a ftn and multibinding can only be wrt this QI, which means
					// within the module/pkg scope. I'm handling multibdg but not a tuple accessed via QI
					// with a ftn-valued attrib, which would lead to a.b.c(...)
					if itemExists(sym, "varany") {
						// could be a vararg ftn either BI or in a pkg. The plist has initial types, beyond those are varargs
						return tcVarargsFn(sym, t, tci)
					}
					argsx := make([]Term, len(t.args))
					i := 0
					for {
						var acfn *Symbol
						sym, acfn = sym.MatchFun(t.args, argsx, cntt, tci)
						if sym != nil {
							rettyp := sym.dtype.v.(*Ftntype).rettype
							if cntt == TypeNothing {
								rettyp = cntt
							}
							ret := makeFuncall(sym, argsx, rettyp, t)
							if acfn != nil {
								ret = makeFuncall(acfn, []Term{ret}, cntt, t)
							}
							return ret
						}
						if i == upc {
							break
						}
						i++
						sym = qi.scope.LookupN(fnname, i)
					}
				}
				mdlpkg := "module"
				if !qi.isModule {
					mdlpkg = "package"
				}
				msg := fmt.Sprintf("no interpretation of %s in %s tagged %s", fnname, mdlpkg, a0tok.val)
				return tci.Error(msg, t)
			}
		}
		// we have x.y(z,w) and we know x isn't a QI. Maybe y is a ftn-valued attribute of x
		dotrm0 := dotrm.arg0.Typecheck(nil, tci)
		if dotrm0.Tag() == ErrorTag {
			return dotrm0
		}
		if dotrm0.Dtype().family == TFTuple {
			tupt := dotrm0.Dtype().v.(*Tupletype)
			arg1 := dotrm.arg1.(*Token).val
			argsx := make([]Term, len(t.args))
			for _, atrb := range tupt.attribs {
				if atrb.ident == arg1 && atrb.dtype.family == TFFtn {
					tci.makeTentative()
					sym, acfn := atrb.MatchFun(t.args, argsx, cntt, tci)
					tci.unmakeTentative()
					if sym != nil {
						// we got a match; make sure to include the full access path to the function
						fntyp := atrb.dtype
						if dotrm0.Tag() == SymbolTag {
							tmp := makeTermL(Symchain, []Term{dotrm0, sym}, fntyp, dotrm0.First(), dotrm0.Final())
							dotrm0 = tmp
						} else { // has to be Symchain (?)
							sc := dotrm0.(*TermL)
							sc.args = append(sc.args, sym)
							sc.dtype = fntyp
							dotrm0 = sc
						}
						ret := makeFuncall(dotrm0, argsx, fntyp.v.(*Ftntype).rettype, t)
						if acfn != nil {
							ret = makeFuncall(acfn, []Term{ret}, cntt, t)
						}
						return ret
					}
				}
			}

		}
		// try rewriting x.y(z,w) to y(x,z,w)
		args := make([]Term, len(t.args)+1)
		copy(args[1:], t.args)
		args[0] = dotrm.arg0
		rslt := makeFuncall(dotrm.arg1, args, nil, t).Typecheck(cntt, tci)
		if rslt.Tag() != ErrorTag {
			return rslt
		}
		retval = rslt
	} else if ftntag == Ident {
		var argsx []Term
		var sym, acfn *Symbol
		ftnname := t.trm.(*Token).val
		// first, check if it's an implicit self.M refnc
		sym, _ = tci.scopes.Lookup("self")
		if sym != nil {
			inx := sym.dtype.methodIndex(ftnname)
			if inx >= 0 && inx < len(sym.dtype.methods) {
				mthdsym := sym.dtype.methods[inx].sym
				if mthdsym.ident == ftnname {
					actuals := make([]Term, len(t.args)+1)
					copy(actuals[1:], t.args)
					argsx = make([]Term, len(t.args)+1)
					argsx[0] = sym
					var cur *Symbol
					cur, acfn = mthdsym.MatchFun(actuals, argsx, cntt, tci)
					if cur != nil {
						t.trm = cur
						t.args = argsx
						t.dtype = cur.Dtype().v.(*Ftntype).rettype
						if cntt == TypeNothing {
							t.dtype = cntt
						} else if acfn != nil {
							t = makeFuncall(acfn, []Term{t}, cntt, t)
						}
						return t
					}
				}
			} else if sym.dtype.attributeLookup(ftnname) != nil {
				attribsym := sym.dtype.attributeLookup(ftnname)
				attribx := makeTermL(Symchain, []Term{sym, attribsym}, attribsym.dtype, Pos(-1), Pos(-1))
				tci.trySymchainfixNP(attribx)
				if attribx.dtype.family == TFFtn {
					if attribsym.dtype.family != TFFtn {
						// grumble: must improvise the symbol if it was nilposs
						attribsym = makeSymbol(attribsym.ident, attribx.dtype, attribsym.binding)
					}
					actuals := make([]Term, len(t.args))
					copy(actuals, t.args)
					argsx = make([]Term, len(t.args))
					var cur *Symbol
					cur, acfn = attribsym.MatchFun(actuals, argsx, cntt, tci)
					if cur != nil {
						t.trm = attribx
						t.args = argsx
						t.dtype = cur.Dtype().v.(*Ftntype).rettype
						if cntt == TypeNothing {
							t.dtype = cntt
						} else if acfn != nil {
							t = makeFuncall(acfn, []Term{t}, cntt, t)
						}
						return t
					}
				}
			}
		}
		// Next, try as a method
		var a0 Term
		if len(t.args) > 0 {
			sym = nil
			a0 = t.args[0].Typecheck(nil, tci)
			if a0.Tag() == ErrorTag {
				tci.innerError = a0
			} else {
				a0t := a0.Dtype()
				if a0t.family == TFOrtype { // check for guarding if needed
					gdi := tci.findTagGuard(a0)
					if gdi != nil && !gdi.invalid && gdi.pos {
						a0t = a0t.v.(*Ortype).variants[gdi.kind-2].dtype
						a0 = makeTermT(Gdref, a0, a0t, Pos(-1), Pos(-1))
					} else {
						// todo: check for nilposs
					}
				} else if tci.inXprftn && a0t == Gzterm {
					// Pattern args need to match functions by name, not necessarily by type
					ftargs := make([]*Type, len(t.args))
					for i, _ := range ftargs {
						ftargs[i] = Gzterm
					}
					ftntyp := makeType(TFFtn, ftargs, Gzterm, true)
					ftnptn := makeSymbol(ftnname, ftntyp, nil)
					ptnargs := make([]Term, len(t.args))
					ptnargs[0] = a0
					for i, a := range t.args {
						if i == 0 {
							continue
						}
						ptnargs[i] = a.Typecheck(nil, tci)
						if ptnargs[i].Tag() == ErrorTag {
							return ptnargs[i]
						}
					}
					return makeFuncall(ftnptn, ptnargs, Gzterm, t)
				}
				mthds := a0t.methods
				inx := mthds.Index(ftnname)
				// special code below checks for list not empty guarding cases
				// -1: unused, 0: main type; 1: nil type
				// we don't bother with nil type for now
				var notnil = -1
				if a0t.family == TFList && guardedListMethod(ftnname) {
					gditem := tci.findListGuard(a0)
					if gditem == nil && a0.Tag() == Symchain {
						// There could be relevant type-based assertions along the chain
						a0l := a0.(*TermL)
						for i := len(a0l.args) - 2; i >= 0; i-- {
							xtyp := a0l.args[i].Dtype()
							if xtyp.asserts != nil {
								if xtyp.asserts.GuardsList(a0l.args[i+1].(*Symbol)) {
									notnil = 0
									break
								}
							}
						}
					}
					if gditem != nil {
						notnil = 0
					}
				}
				// in the following conditions, one of the 5 guardable list methods should match; fix cntt so it might
				if cntt != nil && cntt.family != TFOrtype && cntt != TypeNothing && notnil == 0 {
					cntt = makeNilposs(cntt)
				}
				if inx < len(mthds) && mthds[inx].sym.ident == ftnname {
					// this loop checks all multibound methods, which are stored contiguously
					argsx = make([]Term, len(t.args))
					argsx[0] = a0
					for ; inx < len(mthds) && mthds[inx].sym.ident == ftnname; inx++ {
						tci.makeTentative()
						sym, acfn = mthds[inx].sym.MatchFun(t.args, argsx, cntt, tci)
						if sym == nil && len(argsx) == len(mthds[inx].sym.dtype.v.(*Ftntype).fmlargs) && len(tci.errors) > 0 {
							// close match, save the errmsg in case we might need it later
							tci.innerError = tci.errors[0]
						}
						tci.unmakeTentative()
						if sym != nil {
							break
						}
					}
				} else if a0t.family == TFTypred {
					affs := a0t.v.(*Typred).affs
					inx := affs.binsearch(ftnname)
					if inx >= 0 && inx < len(affs) && affs[inx].ident == ftnname {
						argsx = make([]Term, len(t.args))
						argsx[0] = a0
						tci.makeTentative()
						sym, acfn = affs[inx].MatchFun(t.args, argsx, cntt, tci)
						tci.unmakeTentative()
					}
				}
				// The next check is needed to attempt enumeration of things that don't have maplst (etc) methods.
				// I am not sure the "isChainop(ftnname)" condition suffices
				if sym == nil && isChainop(ftnname) {
					eltyp := a0t.Elttype()
					if eltyp != nil {
						// eltyp != nil means rcvr is enumerable and we're calling a chainop; invoke enumonly special handling
						argsx = make([]Term, len(t.args))
						argsx[0] = a0
						listt := makeListType(eltyp)
						inx = listt.methods.Index(ftnname) // guaranteed to work
						sym, acfn = listt.methods[inx].sym.MatchFun(t.args, argsx, cntt, tci)
					}
				}
				if sym != nil {
					rettyp := sym.dtype.v.(*Ftntype).rettype
					if rettyp.isNilposs() && notnil == 0 {
						rettyp = rettyp.mainType()
					} else if cntt == TypeNothing {
						rettyp = TypeNothing
					} else if rettyp.family == TFTypred && itemExists(sym.binding, "expectedType") {
						rettyp = cntt
					}
					ret := makeFuncall(sym, argsx, rettyp, t)
					if acfn != nil {
						ret = makeFuncall(acfn, []Term{ret}, acfn.dtype.v.(*Ftntype).rettype, t)
					}
					return ret
				}
				// backup 1: affordance based GTS
				if a0t.family == TFGTS {
					typred := a0t.v.(*GTS).dtype.v.(*Typred)
					argsx = make([]Term, len(t.args))
					for _, aff := range typred.affs {
						if aff.ident == ftnname && aff.dtype.family == TFFtn {
							var ok *Symbol
							ok, acfn = aff.MatchFun(t.args, argsx, cntt, tci)
							if ok != nil {
								t.trm = ok
								t.args = argsx
								t.dtype = ok.dtype.v.(*Ftntype).rettype
								if acfn != nil {
									t = makeFuncall(acfn, []Term{t}, cntt, t)
								}
								return t
							}
						}
					}
				}
				// fall through
			}
		}
		// Not a method, try multibound lookup in the scope tree
		argsx = make([]Term, len(t.args))
		if len(argsx) > 0 && a0.Tag() != ErrorTag {
			argsx[0] = a0 // will be good
		}
		// check in the (possibly nested) list of ftns being defined
		sym = nil
		for i := len(tci.ftnInDef) - 1; i >= 0; i-- {
			symrec := tci.ftnInDef[i]
			if symrec.ident == ftnname {
				symrec, acfn = symrec.MatchFun(t.args, argsx, cntt, tci)
				if symrec != nil {
					symrec.plist.Add("recursive", true) // record direct recursion
					sym = symrec
					break
				}
			}
		}
		if sym == nil {
			sym, acfn = tci.scopes.LookupFtn(ftnname, t.args, argsx, cntt, tci)
		}
		if sym != nil {
			if sym.plist.Find("varany") != nil {
				return tcVarargsFn(sym, t, tci)
			}
			rettyp := sym.dtype.v.(*Ftntype).rettype
			if cntt == TypeNothing {
				rettyp = cntt
			}
			ret := makeFuncall(sym, argsx, rettyp, t)
			if acfn != nil {
				ret = makeFuncall(acfn, []Term{ret}, cntt, t)
			}
			return ret
		} else {
			// at this point we've tried everything; format an errmsg and return an error.
			var msgstrg string
			if len(tci.considered) == nconsidered {
				msgstrg = fmt.Sprintf("no method or function named %s", ftnname)
				if nconsidered > 0 && tci.innerError != nil {
					msgstrg = tci.innerError.(*TermB).value
				}
			} else if cntt != nil && tci.innerError == nil {
				msgstrg = fmt.Sprintf("function %s fails to match on return type", ftnname)
			} else {
				msgstrg = fmt.Sprintf("cannot match %s", ftnname)
			}
			if tci.innerError != nil {
				msgstrg += fmt.Sprintf(", possibly because %s", tci.innerError.(*TermB).value)
			}
			retval = tci.Error(msgstrg, t)
		}
	}
	return
}

// The post-TC tag for litforms is Litform0 and we change the type from *TermTL (post-parse)
// to *TermL (post-TC). Therefore, TCLitform never smashes its rcvr. For lithook matches,
// it returns a synthd Funcall. And of course, it returns an ErrorTag term for errors.
func (t *TermTL) TCLitform(cntt *Type, tci *TCInfo) Term {
	if t.trm != nil {
		ttterm := TC4Type(t.trm, nil, tci)
		if ttterm.Tag() == ErrorTag {
			return ttterm
		}
		tagtype := ttterm.(*Type)
		if cntt != nil {
			seen := []*Type{}
			if !tagtype.compat(cntt, &seen) {
				// make an exception for range litforms in each iteree position
				if !(cntt == TPEnumerable && tagtype.rangeType()) {
					return tci.ErrorExpect(cntt, tagtype, t)
				}
			}
		}
		cntt = tagtype
	}
	if len(t.args) == 0 {
		if cntt == nil {
			return tci.Error("empty litform is missing type information", t)
		} else if cntt.family == TFList || cntt.family == TFGTS {
			if cntt.family == TFGTS && cntt.v.(*GTS).binding != nil {
				cntt = cntt.v.(*GTS).binding
			}
			return makeTermL(Litform0, t.args, cntt, t.first, t.final)
		}
	}
	// All or no args may be anchor tagged. If cntt is a tuple type, check for lithook + use that as guidance.
	// Infer to list if no guidance.
	anchortags := 0
	for _, a := range t.args {
		if a.Tag() == TildeExpr {
			anchortags += 1
		}
	}
	if anchortags > 0 && anchortags == len(t.args) {
		// here, we infer anon tuptype if no guidance, else attribs can be out of order
		// todo: this may be out of spec, maybe need to check if there's a type in scope with same attribs and infer to that
		var atrbs *Tupletype
		if cntt != nil && cntt.family == TFTuple {
			atrbs = cntt.v.(*Tupletype)
		}
		attribs := make([]*Symbol, len(t.args))
		vals := make([]Term, len(t.args))
		for i, a := range t.args {
			// since these are anchor tagged, each elt is a TermTT; parser didn't vfy that lhs is an ident
			tag := a.(*TermTT).arg0
			val := a.(*TermTT).arg1
			if tag.Tag() != Ident {
				return tci.Error(fmt.Sprintf("'%s' must be an identifier", tag.String()), t)
			}
			var atrbcntt *Type
			if atrbs != nil { // handle out of order
				tgident := tag.(*Token).val
				inx := atrbs.attribIndex(tgident)
				if inx < 0 {
					return tci.Error(fmt.Sprintf("%s is not an attribute of %s", tgident, cntt), t)
				}
				atrbcntt = atrbs.attribs[inx].dtype
			}
			val0 := val.Typecheck(atrbcntt, tci)
			if val0.Tag() == ErrorTag {
				return val0
			}
			attribs[i] = makeSymbol(tag.(*Token).val, val0.Dtype(), nil)
			vals[i] = val0
		}
		anontype := makeType(TFTuple, attribs, false)
		// we've checked for concrete tuptype cntt but not other cases: GTS => bind, other => error
		if cntt != nil && cntt.family != TFTuple {
			if cntt.family == TFGTS {
				seen := []*Type{}
				// normally, this compat call is only for side effects
				if !anontype.compat(cntt, &seen) {
					return tci.Error(fmt.Sprintf("GTS %s doesn't match tuples", cntt.String()), t)
				}
			} else {
				return tci.Error(fmt.Sprintf("litform cannot match type %s", cntt.String()), t)
			}
		}
		if cntt != nil && cntt.family == TFTuple {
			anontype = cntt
		}
		return makeTermL(Litform0, vals, anontype, t.first, t.final)
	} else if anchortags != 0 {
		return tci.Error("litform must use anchor tags everywhere or not at all", t)
	} else {
		// here, no anchor tags, so do std TC
		if cntt == nil || cntt.family == TFOrtype {
			// infer to list(something)
			vals := make([]Term, len(t.args))
			var cntt0 *Type
			if len(t.args) == 0 {
				if cntt == nil {
					return tci.Error("cannot infer [] here", t)
				} else {
					vnts := cntt.v.(*Ortype).variants
					for _, v := range vnts {
						if v.dtype.family == TFList {
							cntt0 = v.dtype.Elttype()
						}
					}
					if cntt0 == nil {
						panic("shouldn't happen")
					}
				}
			} else {
				for i, a := range t.args {
					val0 := a.Typecheck(cntt0, tci)
					if val0.Tag() == ErrorTag {
						return val0
					}
					if cntt0 == nil {
						cntt0 = val0.Dtype()
					}
					vals[i] = val0
				}
			}
			return makeTermL(Litform0, vals, makeListType(cntt0), t.first, t.final)
		} else {
			// can be list+space+tuple. If tuple, check for lithook RW.
			if cntt == TPEnumerable && tci.inXprftn {
				cntt = Gztermlist
			}
			fam := cntt.family
			getElttype := true
			// Note on enumerable: if we get here with cntt set to TPEnumerable, it's list; a lithook would have to be labeled.
			if cntt == TPList || cntt == TPEnumerable || generalizedType(cntt) {
				fam = TFList
				getElttype = false
			}
			switch fam {
			case TFList:
				vals := make([]Term, len(t.args))
				var elttyp *Type
				if getElttype {
					elttyp = cntt.v.(*Type)
				}
				for i, a := range t.args {
					val0 := a.Typecheck(elttyp, tci)
					if val0.Tag() == ErrorTag {
						return val0
					}
					if elttyp == nil && cntt == TPEnumerable {
						elttyp = val0.Dtype()
						cntt = makeListType(elttyp)
					}
					vals[i] = val0
				}
				return makeTermL(Litform0, vals, cntt, t.first, t.final)
			case TFSpace:
				panic("unwritten")
			case TFTuple:
				var lithooks []*Symbol
				attribs := cntt.v.(*Tupletype).attribs
				for _, m := range cntt.methods {
					if m.sym.ident == "lithook" {
						lithooks = append(lithooks, m.sym)
					}
				}
				// try lithooks first; check if list-accepting
				for lhi := 0; lhi < len(lithooks); lhi++ {
					lh := lithooks[lhi]
					ft := lh.dtype.v.(*Ftntype)
					var synthdList Term
					if len(ft.fmlargs) == 2 && ft.fmlargs[1].family == TFList { // could be list-accepting
						if len(t.args) == 1 { // possible that a list is provided: TC w/o cntt and check
							val0 := t.args[0].Typecheck(nil, tci)
							if val0.Tag() == ErrorTag {
								return val0
							}
							seen := []*Type{}
							val0t := val0.Dtype()
							reqtyp := ft.fmlargs[1]
							if val0t.compat(reqtyp, &seen) {
								synthdList = val0
							} else if reqtyp.family == TFList && val0t.compat(reqtyp.v.(*Type), &seen) {
								synthdList = makeTermL(Litform0, []Term{val0}, ft.fmlargs[1], Pos(-1), Pos(-1))
							}
						} else {
							vals := make([]Term, len(t.args))
							elttyp := ft.fmlargs[1].v.(*Type)
							for i, a := range t.args {
								val0 := a.Typecheck(elttyp, tci)
								if val0.Tag() == ErrorTag {
									return val0
								}
								vals[i] = val0
							}
							synthdList = makeTermL(Litform0, vals, ft.fmlargs[1], Pos(-1), Pos(-1))
						}
						if synthdList != nil {
							selfarg := makeTermT(ZeroValue, nil, ft.rettype, Pos(-1), Pos(-1))
							return makeFuncall(lh, []Term{selfarg, synthdList}, ft.rettype, t)
						}
					}
				}
				// at this point, we've covered the list-accepting lithook case; check for other lithook cases
				if len(lithooks) > 0 {
					svInner := tci.innerError
					defer func() { tci.innerError = svInner }()
					cooked := make([]Term, len(t.args)+1)
					xacts := make([]Term, len(t.args)+1)
					copy(xacts[1:], t.args)
					lastLHInx := len(lithooks) - 1
					for i, lh := range lithooks {
						ft := lh.dtype.v.(*Ftntype)
						if len(ft.fmlargs) == len(xacts) {
							cooked[0] = makeTermT(ZeroValue, nil, ft.rettype, Pos(-1), Pos(-1))
							if i != lastLHInx {
								tci.makeTentative()
							}
							//cooked[0] = lh.binding.(*Funinst).funargs[0]
							matched, acfn := lh.MatchFun(xacts, cooked, ft.rettype, tci)
							if i != lastLHInx {
								tci.unmakeTentative()
							}
							if matched != nil {
								ret := subst4TypredLithook(makeFuncall(matched, cooked, ft.rettype, t))
								if acfn != nil {
									ret.dtype = matched.dtype.v.(*Ftntype).rettype
									ret = makeFuncall(acfn, []Term{ret}, ft.rettype, t)
								}
								return ret
							}
						}
					}
					nhooks := "lithook signature fails to match"
					if len(lithooks) > 1 {
						nhooks = "no lithook matches"
					} else if tci.innerError != nil && tci.innerError != svInner {
						nhooks = "in lithook: " + tci.innerError.(*TermB).value
					}
					return tci.Error(nhooks, t)
				}
				// and here, it's not lithook, so try for the std tuple way of doing things
				cooked := make([]Term, len(t.args))
				if len(t.args) != len(attribs) {
					return tci.Error("litform has wrong number of arguments", t)
				}
				for i, atrb := range attribs {
					tmp := t.args[i].Typecheck(atrb.dtype, tci)
					if tmp.Tag() == ErrorTag {
						return tmp
					}
					cooked[i] = tmp
				}
				return subst4TypredLitform(makeTermL(Litform0, cooked, cntt, t.first, t.final))
			default:
				return tci.Error(fmt.Sprintf("type %s doesn't use litform syntax", cntt), t)
			}
		}
	}
}

// modcheck gets a funcall or error term. If it's a mod funcall and the rcvr isn't a var, return
// a newly created error term, else the incoming term.
func modcheck(trm Term, tci *TCInfo) (retval Term) {
	retval = trm
	if trm.Tag() == Funcall && !tci.inXprftn {
		trm0 := trm.(*TermTL)
		fn := trm0.trm
		if fn.Dtype().isMod() {
			rcvr := trm0.args[0]
			if rcvr.Tag() == Symchain {
				rcvr = rcvr.(*TermL).args[0]
			}
			if rcvr.Tag() == SymbolTag && itemExistsNot(rcvr, "var") && itemExistsNot(fn, "purified") &&
				itemExistsNot(rcvr, "itervar") && itemExistsNot(rcvr, "rcvrLinked") {
				retval = tci.Error("mod function cannot have val as receiver", trm)
			}
		}
	}
	return
}

// funcall, given, litform, typecase
func (t *TermTL) Typecheck(cntt *Type, tci *TCInfo) Term {
	tci.RecordBackup(t)
	switch t.kind {
	case Funcall:
		tci.innerError = nil
		return Simplify(modcheck(t.TCFuncall(cntt, tci), tci))
	case GivenStmt:
		if cntt != nil && cntt.family != TFNothing {
			return tci.ErrorExpectStmt("given", cntt, t)
		}
		// trm is body (stmtlist) and args is decls, each a triple with the last being token __single or __double
		givenscope := makeScope()
		tci.PushScope(givenscope) // push now so dependent decls work
		for _, sd := range t.args {
			symd := sd.(*TermL).singleDouble(tci)
			if symd.Tag() == ErrorTag {
				return symd
			}
			givenscope.Add(symd.(*Symbol), 0)
		}
		// now TC the body with restrictions a/w given (eg only defns, stmap, etc)
		tci.cxt.Push(t.kind)
		tci.cxt.SetItem("givenscope", givenscope)
		// "open code" stmtlists to avoid having an extra level of scope that we don't want
		var defns []Term
		if t.trm.Tag() == Stmts {
			defns = t.trm.(*TermL).args
		} else {
			defns = []Term{t.trm}
		}
		for _, defn := range defns {
			def0 := defn.Typecheck(TypeNothing, tci)
			if def0.Tag() == ErrorTag {
				return def0
			}
			// The givenscope should not be in the chain after TC
			if def0.Tag() == Valdecl {
				defsym := def0.(*TermT).arg0.(*Symbol)
				if defsym.binding != nil && defsym.binding.Tag() == FuninstTag {
					funi := defsym.binding.(*Funinst)
					funi.scope.parent = funi.scope.parent.parent
				}
			}
		}
		tci.cxt.Pop()
		tci.PopScope()
		// fall through and return the unprocessed Term, since effects are seen via affected scope(s)
	case Litform:
		return t.TCLitform(cntt, tci)
	case Typecase:
		// first, check that clauses are correctly formed and that expr is ortype or typred
		for _, clz := range t.args {
			if clz.Tag() != Arrow {
				return tci.Error("case clause expected", clz)
			}
		}
		casex := t.trm.Typecheck(nil, tci)
		if casex.Tag() == ErrorTag {
			return casex
		}
		casextype := casex.Dtype()
		if !(casextype.family == TFOrtype || casextype.family == TFTypred) {
			return tci.Error("type case expression is a manifest type!", casex)
		}
		// ok, now check the clauses
		cntt0 := cntt
		tci.EnterGuardingCxt()
		defer tci.ExitGuardingCxt(Typecase)
		// prepare to manage a gditem case by case
		var gdiIndex = -1

		for clzinx, clz := range t.args {
			clz0 := clz.(*TermTT)
			var casetype Term
			if tokenNamed(clz0.arg0, "else") {
				if clzinx < len(t.args)-1 {
					return tci.Error("else must be last clause of case", t)
				}
				casetype = TPEntity // encode else as entity
			} else {
				casetype = TC4Type(clz0.arg0, casextype, tci)
			}
			if casetype.Tag() == ErrorTag {
				return casetype
			}
			// wrap casex in a Gdref
			if casextype.family == TFOrtype {
				// we don't have the tag, need to find index based on types
				vnts := casextype.v.(*Ortype).variants
				inx := 0
				for _, vnt := range vnts {
					if casetype.Equal(vnt.dtype) {
						break
					}
					inx += 1
				}
				if inx == len(vnts) {
					return tci.Error(fmt.Sprintf("%s isn't a variant of %s", casetype.String(), casextype.String()), t)
				}
				if gdiIndex < 0 {
					gdiIndex = len(tci.gditems)
					tci.addGuarditem(true, inx+2, casex)
				} else {
					tci.gditems[gdiIndex].kind = inx + 2
				}
			} else {
				// We've already vfyd that casextype is either ortype or typred, so that leaves typred.
				tci.addGuarditem(true, -1, casex)
				tci.typecaseType = casetype.(*Type)
			}
			rhs := clz0.arg1.Typecheck(cntt0, tci)
			if rhs.Tag() == ErrorTag {
				return rhs
			}
			if cntt0 == nil {
				cntt0 = rhs.Dtype()
			}
			// single stmt rhs's must be wrapped in a stmtlist else OOLXforms fails
			if rhs.Tag() != Stmts {
				scp := makeScope()
				scp.parent = tci.scopes
				rhs = makeScopedTermL(Stmts, scp, []Term{rhs}, cntt0, clz0.first, clz0.final)
			}
			// smash clause with internd terms
			clz0.arg0 = casetype
			clz0.arg1 = rhs
			clz0.dtype = cntt0
		}
		tci.typecaseType = nil
		t.trm = casex
		t.dtype = cntt0
	}
	return t
}
