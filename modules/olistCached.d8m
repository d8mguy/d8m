// OlistCached is a
// variant of ordered lists; has internal cache named recent. Full list in slot named official. Code to merge recent
// into official, either on demand or when recent gets full. The timing behavior is somewhat complex; it's likely a net
// loss for most uses. If the usage pattern involves lookups of recently added elements, then it's likely to win.
//
// The cache size is part of the type, that is, is an arg to the typegen. I'm not sure this is a good decision. It could
// certainly go the other way.
//
// Note: old comments below, to be extracted from then deleted.
// Two olists named official and recent, both represented internally as list(T) and stored according to the ordering.
// Insert adds to recent and merges this "cache" to official when its size exceeds the value of the thresh attribute.
// This means that $in has to test both recent and official so will generally be slower than straight olist.
// However, insert will almost always be faster and even the amortized time should be faster, since moving a large
// number of items from recent to official is done in a single pass and has better cache behavior than adding the same
// number of items at random places in the large olist. Delete will only be faster if the item is found in recent; so
// another advantageous case for this version is if recently added items are accessed and/or deleted more than older ones.
//
// The semantics of ordering is the same as for olist; see the extensive discussion there for details. The short version
// is that the typegen parameter here called `xfn` should create a total order on `T`.

export olistCached

given(U::ordered) {
	val olistCached = \typegen(T::entity, xfn:\(T)->U, thresh: integer) {
		extend tuple(private official, recent: list(T), private limit: integer) where {
			// binsearch ftn that'll be used on both official and recent: returns index of elt <= oelt or -1 if no such elt
			val indexA = \imp(lst: list(T), oelt: U) {
				if(lst == [] || xfn(lst.last) < oelt) { -1 }
				else {
					var mn = 0, mx = lst.count-1, cur = mx/2
					while(mn <= mx) {
						val ocur = xfn(lst[cur])
						if(ocur < oelt) mn = cur+1
						else if(ocur == oelt) break
						else mx = cur-1
						cur = mn + (mx - mn)/2
					}
					cur
				}
			}
			// Integrates recent into official; use cleverness to ensure elts of official are moved at most once.
			private method list2official = \mod() {
			    val olenb4 = official.count
				official.insert(official.count, recent)
			    if(olenb4 > 0 && recent.count > 0) {
                    var inxo = olenb4 - 1, inxl = recent.count - 1
                    var destinx = inxo + inxl + 1
                    var oelt = xfn(official[inxo]), relt = xfn(recent[inxl])
                    loop {
                        if(oelt < relt) {
                            official[destinx] = recent[inxl]
                            inxl -= 1
                            if(inxl < 0) break
                            relt = xfn(recent[inxl])
                        } else {
                            official[destinx] = official[inxo]
                            inxo -= 1
                            if(inxo < 0) break
                            oelt = xfn(official[inxo])
                        }
                        destinx -= 1
                    }
                    if(inxl >= 0) copyFrom(official, 0, recent.select(0, inxl+1))
                }
                recent = recent.select(0,0)
/*
                var ordCount = 0
                var curval = xfn(official[0])
                var badinx = 0
                each(i^1...official.count) { val tmp = xfn(official[i]); if(curval < tmp) ordCount += 1 else badinx = i; curval = tmp }
                unless(recent.count == 0 && ordCount == official.count - 1) {
                    println("rc=", recent.count, ";oc=", ordCount, ";bi=", badinx)
                }
*/
			}

			// This lookup code should be almost as fast as a std olist when recent is empty. But if lookups to recent
			// insertions are common, it will be slower than a code that tests recent first.
			method $in = \(elt: T) -> boolean {
				val oelt = xfn(elt)
				val inx = indexA(official, oelt)
				if(inx >= 0 && official[inx] == elt) true
				else if(recent.count > 0) {
					val rinx = indexA(recent, oelt)
					rinx >= 0 && recent[rinx] == elt
				} else false
			}

            // Is like $in but only tests the key
            method keyIn = \(oelt: U) -> boolean {
                val inx = indexA(recent, oelt)
                if(inx >= 0 && xfn(recent[inx]) == oelt) true
                else {
                    val oinx = indexA(official, oelt)
                    oinx >= 0 && xfn(official[oinx]) == oelt
                }
            }

            // Returns the (first) elt whose oextract is oelt, or nil
            method get = \(oelt: U) -> nilPossible(T) {
                val inx = indexA(recent, oelt)
                if(inx >= 0 && xfn(recent[inx]) == oelt) recent[inx]
                else {
                    val oinx = indexA(official, oelt)
                    if(oinx >= 0 && xfn(official[oinx]) == oelt) official[oinx] else nil
                }
            }

			// inserts elt into recent, after checking whether recent.count == thresh and flushing it if so
			method insert = \mod(elt: T) -> nothing {
				if(recent.count >= limit) list2official()
				val inx = indexA(recent, xfn(elt))
				if(inx < 0) recent.pushb(elt)
				else recent.insert(inx, elt)
			}

            // same as insert but checks first.
			method insertIfUniq = \mod(elt: T) -> nothing {
				unless(elt in self) insert(elt)
			}

			method lithook = \mod(elts: list(T)) {
				recent = []
				official = []
				if(thresh == 0) exit("olistCached cannot be initialized with cache size = 0")
				limit = thresh
				each(e^elts) insert(e)
			}

            // is defined to support stmapping from set to olist.
            method lithook = \mod(elts: list(T), noDups: boolean) {
                if(noDups) each(e^elts) self.insertIfUniq(e)
                self
            }

			method count = \() -> integer { official.count + recent.count }
			method remove = \mod(elt: T) -> nothing {
				val oelt = xfn(elt)
				var inx = indexA(recent, oelt)
				var done = false
				if(inx >= 0) {
				    while(inx < recent.count && xfn(recent[inx]) == oelt) {
				        if(recent[inx] == elt) { recent.removeIndex(inx); done = true; break }
				        inx += 1
				    }
				}
				unless(done) {
					inx = indexA(official, oelt)
					if(inx >= 0) {
                        while(inx < official.count && xfn(official[inx]) == oelt) {
                            if(official[inx] == elt) { official.removeIndex(inx); break }
                            inx += 1
                        }
					}
				}
			}
			// Empties recent, aka "flushes the cache". This is experimental, thought to be possibly helpful for tuning
			// when we're about to do a lot of lookups. Probably overkill in fact.
			method flush = \mod() -> nothing { list2official() }
			method eachstart = \imp() {
				val theOls = self		// have to refnc the type inside the nested type
				val estype = extend tuple(inxr, inxo: integer, onRecent: boolean) where {
					method value = \mod() {
					    onRecent = (inxo >= theOls.official.count || xfn(theOls.recent[inxr]) <= xfn(theOls.official[inxo]))
					    onRecent ? theOls.recent[inxr] : theOls.official[inxo]
					}
					method eachdone = \() { inxr >= theOls.recent.count && inxo >= theOls.official.count }
					method eachstep = \mod() {
						if(onRecent) inxr += 1 else inxo += 1
					}
				}
				// the eachstart prcl requires eachstep to return nothing, which is inconvenient in this case
				[estype: 0, 0, false]
			}
			method minelt = \() -> nilPossible(T) {
			    if(self.count == 0) nil
			    else if(recent.count == 0) official[0]
			    else if(official.count == 0) recent[0]
			    else {
			        val orcnt = xfn(recent[0]), oocnt = xfn(official[0])
			        orcnt < oocnt ? recent[0] : official[0]
			    }
			}
			method maxelt = \() -> nilPossible(T) {
			    if(self.count == 0) nil
			    else if(recent.count == 0) official[official.count - 1]
			    else if(official.count == 0) recent[recent.count - 1]
			    else {
			        val orcnt = xfn(recent[recent.count - 1]), oocnt = xfn(official[official.count - 1])
			        oocnt < orcnt ? recent[recent.count - 1] : official[official.count - 1]
			    }
			}
			method popf = \mod() -> nilPossible(T) {
			    if(self.count == 0) nil
                else if(recent.count == 0) official.popf()
                else if(official.count == 0) recent.popf()
                else {
                    val orcnt = xfn(recent[0]), oocnt = xfn(0)
                    orcnt < oocnt ? recent.popf : official.popf
                }
			}
			method popb = \mod() -> nilPossible(T) {
			    if(self.count == 0) nil
                else if(recent.count == 0) official.popb
                else if(official.count == 0) recent.popb
                else {
                    val orcnt = xfn(recent[recent.count - 1]), oocnt = xfn(official.count - 1)
                    oocnt < orcnt ? recent.popb : official.popb
                }
			}
		}
	}
}

oncondition defined(set, type) {
    given(T0::entity, OT::ordered, ox:\(T0)->OT, top: integer, aT: T0, aLT: list(T0)) {
        STMap {
            source = set(T0)
            target = olistCached(T0, ox, top)
            direct count, $in
            lithook(aLT) => lithook(aLT, true)
            add(aT) => insertIfUniq(aT)
    		remove(aT) => remove(aT)
        }
    }
}
