// typecase1: verify that substitution of the typeswitch vbl happens in generated code
import "Term" melted
import "strings"
val componentArg = tuple(argname, argtype: string, optional: boolean, universal: boolean)
val componentT = tuple(compnm: string, args: list(componentArg), hasChildren, builtin:boolean)
val PTerm: type = extend tuple(ident: string,
        v: ortype(terms: list(PTerm), leaf: Term, comp: componentT, comparg: componentArg)) where {
    method stringify = \() -> string {
        val args = case v {
        list(PTerm) => strings.join(v.{stringify(this)}, ";")
        Term => stringify(v)
        componentT => v.compnm
        componentArg => v.argname
        }
        "[#{ident}: #{args}]"
    }
    method asTerms = \() { always(x~self.v, tag(x) == :terms) }
    method asLeaf = \() { always(x~self.v, tag(x) == :leaf) }
    method asString = \() { asString(asLeaf(self)) }        // strings are encoded in Terms
    method asComp = \() { always(x~self.v, tag(x) == :comp) }
    method asComparg = \() { always(x~self.v, tag(x) == :comparg) }
    method asError = \() { asString(self) }     // extract error string, assuming generated by makeErrorPTerm
    method child0 = \() { asTerms(self)[0] }
    method child1 = \() { asTerms(self)[1] }
}
val foo = \imp() {
    val pt1 = [PTerm: "aaa", [Term: "bbb", "ccc", 0]]
    stringify(pt1)
}
foo()
